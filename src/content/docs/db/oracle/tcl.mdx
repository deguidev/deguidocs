---
title: 7. TCL (Transaction Control Language)
description: Aprende a gestionar transacciones en Oracle Database
---

import { Code } from '@astrojs/starlight/components';
import { Tabs, TabItem } from '@astrojs/starlight/components';
import { Badge } from '@astrojs/starlight/components';
import { Aside } from '@astrojs/starlight/components';
import { Steps } from '@astrojs/starlight/components';

## Introducción al TCL

El Lenguaje de Control de Transacciones (Transaction Control Language o TCL) es un subconjunto de SQL utilizado para gestionar los cambios realizados por las sentencias DML (Data Manipulation Language). TCL permite a los usuarios agrupar un conjunto de operaciones en unidades lógicas de trabajo llamadas transacciones, que pueden ser confirmadas o revertidas como una unidad.

### Características principales de las transacciones

- **Atomicidad**: Una transacción se ejecuta por completo o no se ejecuta en absoluto
- **Consistencia**: Una transacción lleva la base de datos de un estado consistente a otro estado consistente
- **Aislamiento**: Las transacciones se ejecutan de forma aislada unas de otras
- **Durabilidad**: Una vez confirmada una transacción, sus cambios son permanentes

<Aside type="note">
  Las propiedades ACID (Atomicidad, Consistencia, Aislamiento y Durabilidad) son fundamentales en los sistemas de gestión de bases de datos relacionales como Oracle para garantizar la integridad de los datos.
</Aside>

## COMMIT - Confirmación de transacciones

El comando COMMIT se utiliza para hacer permanentes los cambios realizados durante la transacción actual.

### Sintaxis básica

```sql
-- Sintaxis básica
COMMIT [WORK] [COMMENT 'texto_comentario'];

-- Ejemplo simple
INSERT INTO empleados (empleado_id, nombre, apellido) VALUES (101, 'Juan', 'Pérez');
UPDATE departamentos SET presupuesto = presupuesto + 10000 WHERE departamento_id = 20;
COMMIT; -- Confirma ambas operaciones
```

### Comportamiento del COMMIT

<Steps>
  1. **Hace permanentes los cambios**
     - Los cambios realizados por las sentencias DML se guardan permanentemente en la base de datos
     - Los cambios son visibles para otras sesiones
  
  2. **Libera bloqueos**
     - Se liberan todos los bloqueos adquiridos durante la transacción
     - Otros usuarios pueden acceder a los datos modificados
  
  3. **Establece un punto de guardado**
     - Se establece un punto de guardado implícito
     - Finaliza la transacción actual y comienza una nueva
  
  4. **Libera recursos**
     - Se liberan los recursos del sistema utilizados para la transacción
     - Se eliminan los datos de deshacer (undo) asociados a la transacción
</Steps>

### Tipos de COMMIT

<Tabs>
  <TabItem label="COMMIT estándar">
    ```sql
    -- COMMIT simple
    INSERT INTO clientes (cliente_id, nombre) VALUES (1001, 'Empresa ABC');
    COMMIT;
    
    -- COMMIT con comentario (para auditoría)
    UPDATE productos SET precio = precio * 1.05 WHERE categoria = 'Electrónica';
    COMMIT COMMENT 'Incremento de precios 5% en electrónica';
    ```
  </TabItem>
  
  <TabItem label="COMMIT con opciones avanzadas">
    ```sql
    -- COMMIT FORCE: confirma una transacción en una base de datos distribuida
    -- incluso si algunas bases de datos no están disponibles
    COMMIT FORCE '25.32.87';
    
    -- COMMIT WRITE: controla cómo se escriben los cambios en el redo log
    -- IMMEDIATE: escribe inmediatamente (más seguro)
    -- BATCH: agrupa escrituras (mejor rendimiento)
    COMMIT WRITE IMMEDIATE NOWAIT;
    ```
  </TabItem>
</Tabs>

### COMMIT implícito

Oracle realiza un COMMIT implícito en los siguientes casos:

- Cuando se ejecuta un comando DDL (CREATE, ALTER, DROP, etc.)
- Cuando se ejecuta un comando DCL (GRANT, REVOKE)
- Cuando se cierra normalmente una sesión (EXIT o QUIT)
- Cuando se ejecuta un comando SET AUTOCOMMIT ON

<Aside type="caution">
  Tenga cuidado al ejecutar comandos DDL durante una transacción, ya que provocarán un COMMIT implícito de todos los cambios pendientes. Esto puede llevar a resultados inesperados si no se planifica adecuadamente.
</Aside>

## ROLLBACK - Reversión de cambios

El comando ROLLBACK se utiliza para deshacer los cambios realizados durante la transacción actual que aún no han sido confirmados.

### Sintaxis básica

```sql
-- Sintaxis básica
ROLLBACK [WORK] [TO [SAVEPOINT] nombre_savepoint];

-- Ejemplo simple
INSERT INTO empleados (empleado_id, nombre, apellido) VALUES (102, 'María', 'Gómez');
UPDATE departamentos SET presupuesto = presupuesto - 5000 WHERE departamento_id = 30;

-- Si algo sale mal o se detecta un error
ROLLBACK; -- Revierte ambas operaciones
```

### Comportamiento del ROLLBACK

<Steps>
  1. **Deshace los cambios**
     - Revierte todos los cambios realizados por las sentencias DML desde el último COMMIT o desde el inicio de la transacción
     - Los datos vuelven a su estado anterior
  
  2. **Libera bloqueos**
     - Se liberan todos los bloqueos adquiridos durante la transacción
     - Otros usuarios pueden acceder a los datos
  
  3. **Elimina savepoints**
     - Se eliminan todos los savepoints establecidos durante la transacción
  
  4. **Finaliza la transacción**
     - Termina la transacción actual y comienza una nueva
</Steps>

### ROLLBACK parcial

Utilizando savepoints, es posible realizar un ROLLBACK parcial, deshaciendo solo una parte de la transacción.

```sql
-- Iniciar transacción
INSERT INTO clientes (cliente_id, nombre) VALUES (1002, 'Empresa XYZ');

-- Establecer un savepoint
SAVEPOINT despues_cliente;

-- Continuar la transacción
INSERT INTO pedidos (pedido_id, cliente_id, total) VALUES (5001, 1002, 1500);
INSERT INTO pedidos (pedido_id, cliente_id, total) VALUES (5002, 1002, 2500);

-- Si hay un problema con los pedidos
ROLLBACK TO SAVEPOINT despues_cliente; -- Deshace solo las inserciones de pedidos

-- Continuar con la transacción
INSERT INTO pedidos (pedido_id, cliente_id, total) VALUES (5003, 1002, 3000);

-- Confirmar toda la transacción
COMMIT;
```

### ROLLBACK implícito

Oracle realiza un ROLLBACK implícito en los siguientes casos:

- Cuando se produce un fallo del sistema
- Cuando se cierra anormalmente una sesión (p. ej., por un error de red)
- Cuando se produce un error grave durante la ejecución de una sentencia

<Aside type="tip">
  Es una buena práctica utilizar bloques de control de excepciones en PL/SQL para gestionar los errores y realizar ROLLBACK explícitos cuando sea necesario, en lugar de depender de los ROLLBACK implícitos.
</Aside>

## SAVEPOINT - Puntos de guardado intermedios

El comando SAVEPOINT establece un punto de guardado dentro de la transacción actual, permitiendo deshacer parte de una transacción sin tener que deshacer toda la transacción.

### Sintaxis básica

```sql
-- Sintaxis básica
SAVEPOINT nombre_savepoint;

-- Ejemplo simple
INSERT INTO empleados (empleado_id, nombre) VALUES (103, 'Carlos');
SAVEPOINT sp_despues_empleado;

INSERT INTO departamentos (departamento_id, nombre) VALUES (50, 'Innovación');

-- Si hay un problema con la inserción del departamento
ROLLBACK TO SAVEPOINT sp_despues_empleado;

-- Continuar con la transacción
INSERT INTO departamentos (departamento_id, nombre) VALUES (51, 'Investigación');
COMMIT;
```

### Características de los savepoints

- Se pueden crear múltiples savepoints dentro de una transacción
- Los savepoints permiten un control más granular de las transacciones
- Si se crea un savepoint con el mismo nombre que uno existente, el nuevo savepoint reemplaza al anterior
- Los savepoints se eliminan automáticamente cuando se ejecuta un COMMIT o un ROLLBACK completo

### Gestión de savepoints múltiples

```sql
-- Iniciar transacción
DELETE FROM empleados WHERE departamento_id = 10;
SAVEPOINT sp_despues_eliminar_dept10;

UPDATE empleados SET salario = salario * 1.1 WHERE departamento_id = 20;
SAVEPOINT sp_despues_actualizar_dept20;

INSERT INTO historial_cambios (descripcion) VALUES ('Actualización de salarios dept 20');
SAVEPOINT sp_despues_historial;

-- Si hay un problema con la inserción en el historial
ROLLBACK TO SAVEPOINT sp_despues_actualizar_dept20;

-- Si hay un problema con la actualización de salarios
ROLLBACK TO SAVEPOINT sp_despues_eliminar_dept10;

-- Si todo está bien
COMMIT;
```

<Aside type="note">
  Cuando se hace ROLLBACK a un savepoint, todos los savepoints creados después de ese savepoint se eliminan automáticamente, pero el savepoint al que se hace ROLLBACK se mantiene.
</Aside>

## Manejo de transacciones en Oracle XE

Oracle Database Express Edition (XE) es una versión gratuita de Oracle Database con algunas limitaciones, pero el manejo de transacciones funciona igual que en las versiones estándar.

### Configuración de transacciones

<Tabs>
  <TabItem label="Modo de transacción">
    ```sql
    -- Verificar el modo de transacción actual
    SHOW AUTOCOMMIT;
    
    -- Activar el modo autocommit (cada sentencia es una transacción)
    SET AUTOCOMMIT ON;
    
    -- Desactivar el modo autocommit (modo manual, recomendado)
    SET AUTOCOMMIT OFF;
    ```
  </TabItem>
  
  <TabItem label="Parámetros de transacción">
    ```sql
    -- Consultar parámetros relacionados con transacciones
    SELECT name, value FROM v$parameter 
    WHERE name LIKE '%commit%' OR name LIKE '%undo%';
    
    -- Ver el tamaño máximo de undo
    SELECT name, value FROM v$parameter WHERE name = 'undo_retention';
    ```
  </TabItem>
</Tabs>

### Monitoreo de transacciones

```sql
-- Ver transacciones activas
SELECT xid, status, start_time, log_io, phy_io
FROM v$transaction;

-- Ver sesiones con transacciones pendientes
SELECT s.sid, s.serial#, s.username, s.status, t.used_ublk, t.start_time
FROM v$session s, v$transaction t
WHERE s.saddr = t.ses_addr;

-- Ver bloqueos de transacciones
SELECT l.session_id, s.username, l.lock_type, l.mode_held, l.mode_requested
FROM v$lock l, v$session s
WHERE l.session_id = s.sid
AND l.lock_type = 'TX';
```

### Limitaciones en Oracle XE

Oracle XE tiene algunas limitaciones que pueden afectar a las transacciones:

- Límite de uso de memoria (2GB)
- Límite de almacenamiento (12GB en Oracle XE 18c)
- Límite de uso de CPU (hasta 2 cores)

Estas limitaciones pueden afectar al rendimiento de las transacciones grandes, pero no a su funcionalidad básica.

<Aside type="tip">
  En Oracle XE, es especialmente importante gestionar bien las transacciones debido a las limitaciones de recursos. Evite transacciones muy largas que puedan consumir demasiados recursos de undo y bloquear tablas durante mucho tiempo.
</Aside>

## Niveles de aislamiento de transacciones

Oracle soporta diferentes niveles de aislamiento que determinan cómo interaccionan las transacciones concurrentes.

### Configuración del nivel de aislamiento

```sql
-- Establecer el nivel de aislamiento para la sesión actual
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

-- Establecer el nivel de aislamiento para una transacción específica
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
```

### Niveles de aislamiento disponibles

| Nivel | Descripción | Problemas que previene |
|-------|-------------|------------------------|
| READ COMMITTED | Nivel predeterminado. Solo ve datos confirmados por otras transacciones | Lecturas sucias |
| SERIALIZABLE | Mayor nivel de aislamiento. Ve un snapshot de los datos al inicio de la transacción | Lecturas sucias, lecturas no repetibles, lecturas fantasma |
| READ ONLY | Similar a SERIALIZABLE, pero no permite modificaciones | Lecturas sucias, lecturas no repetibles, lecturas fantasma |

<Aside type="note">
  Oracle no implementa el nivel READ UNCOMMITTED que existe en el estándar SQL. El nivel más bajo en Oracle es READ COMMITTED, que ya previene las lecturas sucias.
</Aside>

## Transacciones distribuidas

Las transacciones distribuidas involucran múltiples bases de datos y utilizan el protocolo de commit en dos fases (2PC) para garantizar la consistencia.

### Configuración de transacciones distribuidas

```sql
-- Crear un enlace de base de datos (database link)
CREATE DATABASE LINK remote_db
  CONNECT TO usuario IDENTIFIED BY contraseña
  USING 'conexion_tns';

-- Iniciar una transacción distribuida
INSERT INTO empleados VALUES (104, 'Ana', 'Martínez');
INSERT INTO empleados@remote_db VALUES (104, 'Ana', 'Martínez');

-- Confirmar la transacción distribuida
COMMIT;
```

### Gestión de errores en transacciones distribuidas

```sql
-- Consultar transacciones distribuidas en duda
SELECT * FROM dba_2pc_pending;

-- Resolver manualmente una transacción en duda
COMMIT FORCE 'transaction_id';
-- o
ROLLBACK FORCE 'transaction_id';
```

## Mejores prácticas para transacciones

<Steps>
  1. **Mantener transacciones cortas**
     - Las transacciones largas consumen más recursos y pueden causar bloqueos prolongados
     - Divida las operaciones grandes en transacciones más pequeñas cuando sea posible
  
  2. **Confirmar o revertir explícitamente**
     - Siempre termine las transacciones con un COMMIT o ROLLBACK explícito
     - Evite depender de los COMMIT o ROLLBACK implícitos
  
  3. **Usar savepoints estratégicamente**
     - Establezca savepoints antes de operaciones complejas o potencialmente problemáticas
     - Use nombres descriptivos para los savepoints
  
  4. **Gestionar bloqueos adecuadamente**
     - Sea consciente de los bloqueos que generan sus transacciones
     - Considere usar SELECT FOR UPDATE cuando sea necesario bloquear filas específicas
  
  5. **Manejar excepciones**
     - Implemente manejo de excepciones adecuado en bloques PL/SQL
     - Realice ROLLBACK en caso de errores inesperados
</Steps>

### Ejemplo de transacción bien estructurada en PL/SQL

```sql
DECLARE
  v_error EXCEPTION;
  v_count NUMBER;
BEGIN
  -- Iniciar transacción (implícito en PL/SQL)
  
  -- Verificar condiciones previas
  SELECT COUNT(*) INTO v_count FROM clientes WHERE cliente_id = 1001;
  IF v_count = 0 THEN
    RAISE v_error;
  END IF;
  
  -- Establecer savepoint
  SAVEPOINT sp_inicio;
  
  -- Realizar operaciones
  INSERT INTO pedidos (pedido_id, cliente_id, total) VALUES (6001, 1001, 5000);
  
  -- Establecer otro savepoint
  SAVEPOINT sp_despues_pedido;
  
  -- Actualizar inventario
  UPDATE inventario SET cantidad = cantidad - 10 WHERE producto_id = 101;
  IF SQL%ROWCOUNT = 0 THEN
    ROLLBACK TO SAVEPOINT sp_despues_pedido;
    RAISE v_error;
  END IF;
  
  -- Confirmar si todo está bien
  COMMIT;
  DBMS_OUTPUT.PUT_LINE('Transacción completada con éxito');
  
EXCEPTION
  WHEN v_error THEN
    ROLLBACK;
    DBMS_OUTPUT.PUT_LINE('Error en la transacción. Cambios revertidos.');
  WHEN OTHERS THEN
    ROLLBACK;
    DBMS_OUTPUT.PUT_LINE('Error inesperado: ' || SQLERRM);
    RAISE;
END;
/
```

<Aside type="caution">
  En entornos de producción, es importante monitorear y gestionar las transacciones largas o bloqueadas, ya que pueden afectar significativamente al rendimiento del sistema y a la experiencia de los usuarios.
</Aside>
