---
title: 09. Optimizaciones de Rendimiento
description: Lazy loading, importaci√≥n inteligente, compresi√≥n de im√°genes y an√°lisis con Lighthouse
---

import { Code } from '@astrojs/starlight/components';
import { Tabs, TabItem } from '@astrojs/starlight/components';
import { Badge } from '@astrojs/starlight/components';
import { Aside } from '@astrojs/starlight/components';
import { Steps } from '@astrojs/starlight/components';


## 9.1 Lazy loading e importaci√≥n inteligente

<Tabs>
  <TabItem label="üëî Parte te√≥rica">
    
    ### Lazy Loading e Importaci√≥n Inteligente

    El **lazy loading** (carga diferida) y la **importaci√≥n inteligente** son t√©cnicas que retrasan la carga de recursos hasta que son realmente necesarios, mejorando significativamente el rendimiento inicial.

    #### üéØ Prop√≥sito

    - Reducir el tiempo de carga inicial de la p√°gina
    - Minimizar el tama√±o del bundle JavaScript
    - Mejorar m√©tricas de rendimiento (FCP, LCP, TTI)
    - Optimizar el uso de ancho de banda
    - Cargar recursos solo cuando el usuario los necesita

    #### üìã Tipos de Lazy Loading

    **1. Lazy Loading de Im√°genes**
    - Cargar im√°genes cuando entran en viewport
    - Atributo `loading="lazy"` nativo
    - Reduce carga inicial significativamente
    - Mejora LCP (Largest Contentful Paint)

    **2. Lazy Loading de Componentes**
    - Dividir c√≥digo en chunks separados
    - Cargar componentes bajo demanda
    - Reduce bundle inicial de JavaScript
    - Mejora TTI (Time to Interactive)

    **3. Lazy Loading de Scripts**
    - Diferir carga de scripts no cr√≠ticos
    - Usar `async` o `defer`
    - Priorizar contenido sobre funcionalidad
    - Mejora FCP (First Contentful Paint)

    #### ‚öôÔ∏è Importaci√≥n Inteligente

    **Dynamic Imports**
    - Sintaxis: `import()` como funci√≥n
    - Retorna una Promise
    - Crea chunks autom√°ticamente
    - Carga bajo demanda

    **Code Splitting**
    - Divisi√≥n autom√°tica del c√≥digo
    - Chunks por ruta o componente
    - Optimizaci√≥n del bundle
    - Carga paralela eficiente

    **Tree Shaking**
    - Eliminaci√≥n de c√≥digo no usado
    - An√°lisis est√°tico de imports
    - Reduce tama√±o del bundle
    - Autom√°tico en build de producci√≥n

    #### üîÑ Estrategias de Carga

    | Estrategia | Cu√°ndo Usar | Ventaja |
    |------------|-------------|---------|
    | **Eager** | Recursos cr√≠ticos | Disponible inmediatamente |
    | **Lazy** | Recursos below-the-fold | Carga inicial r√°pida |
    | **Prefetch** | Recursos probables | Navegaci√≥n r√°pida |
    | **Preload** | Recursos cr√≠ticos futuros | Optimiza ruta cr√≠tica |

    #### üåü Beneficios

    - **Rendimiento**: Carga inicial hasta 50% m√°s r√°pida
    - **Experiencia**: Usuario ve contenido antes
    - **Recursos**: Menos consumo de datos
    - **SEO**: Mejores Core Web Vitals
    - **Escalabilidad**: Soporta m√°s contenido

    #### üìä M√©tricas Impactadas

    - **FCP**: First Contentful Paint (‚Üì 30-40%)
    - **LCP**: Largest Contentful Paint (‚Üì 20-30%)
    - **TTI**: Time to Interactive (‚Üì 40-50%)
    - **TBT**: Total Blocking Time (‚Üì 50-60%)
    - **Bundle Size**: Tama√±o inicial (‚Üì 40-70%)

    #### ‚ö†Ô∏è Consideraciones

    - **Layout Shift**: Reservar espacio para contenido lazy
    - **Fallbacks**: Proporcionar placeholders
    - **Priorizaci√≥n**: Cargar contenido cr√≠tico primero
    - **Testing**: Probar en conexiones lentas
    - **Accesibilidad**: No afectar navegaci√≥n por teclado

  </TabItem>
  <TabItem label="üí° Ejemplos pr√°cticos">
    
    ### üñºÔ∏è Lazy Loading de Im√°genes Nativo

    **HTML nativo con `loading="lazy"`**
    ```astro
    ---
    // src/pages/gallery.astro
    const images = [
      { src: '/images/photo1.jpg', alt: 'Foto 1' },
      { src: '/images/photo2.jpg', alt: 'Foto 2' },
      { src: '/images/photo3.jpg', alt: 'Foto 3' },
    ];
    ---

    <html>
      <body>
        <h1>Galer√≠a</h1>
        
        <!-- Primera imagen: carga inmediata -->
        <img 
          src="/images/hero.jpg" 
          alt="Hero" 
          loading="eager"
          width="1200"
          height="600"
        />
        
        <!-- Resto: lazy loading -->
        {images.map(img => (
          <img 
            src={img.src} 
            alt={img.alt}
            loading="lazy"
            width="400"
            height="300"
          />
        ))}
      </body>
    </html>
    ```

    ### üé® Lazy Loading con Componente Image de Astro

    ```astro
    ---
    import { Image } from 'astro:assets';
    import heroImage from '../assets/hero.jpg';
    import photo1 from '../assets/photo1.jpg';
    import photo2 from '../assets/photo2.jpg';
    ---

    <div class="gallery">
      <!-- Imagen cr√≠tica: eager loading -->
      <Image 
        src={heroImage}
        alt="Hero"
        width={1200}
        height={600}
        format="webp"
        loading="eager"
        quality={90}
      />
      
      <!-- Im√°genes below-the-fold: lazy loading -->
      <Image 
        src={photo1}
        alt="Foto 1"
        width={400}
        height={300}
        format="webp"
        loading="lazy"
        quality={80}
      />
      
      <Image 
        src={photo2}
        alt="Foto 2"
        width={400}
        height={300}
        format="webp"
        loading="lazy"
        quality={80}
      />
    </div>
    ```

    ### ‚öõÔ∏è Lazy Loading de Componentes React

    **Componente pesado**
    ```jsx
    // src/components/HeavyChart.jsx
    import { Chart } from 'chart.js';

    export default function HeavyChart({ data }) {
      // Componente con librer√≠a pesada
      return (
        <div className="chart">
          <Chart data={data} />
        </div>
      );
    }
    ```

    **Uso con lazy loading**
    ```astro
    ---
    // src/pages/dashboard.astro
    import HeavyChart from '../components/HeavyChart.jsx';
    ---

    <html>
      <body>
        <h1>Dashboard</h1>
        
        <!-- Contenido cr√≠tico -->
        <div class="summary">
          <p>Resumen de datos...</p>
        </div>
        
        <!-- Componente pesado con lazy loading -->
        <HeavyChart client:visible data={chartData} />
      </body>
    </html>
    ```

    ### üîÑ Dynamic Import en JavaScript

    **Importaci√≥n din√°mica de m√≥dulo**
    ```astro
    ---
    // src/pages/interactive.astro
    ---

    <html>
      <body>
        <button id="loadChart">Cargar Gr√°fico</button>
        <div id="chartContainer"></div>

        <script>
          const button = document.getElementById('loadChart');
          
          button?.addEventListener('click', async () => {
            // Importaci√≥n din√°mica solo cuando se necesita
            const { Chart } = await import('chart.js/auto');
            
            const ctx = document.getElementById('chartContainer');
            new Chart(ctx, {
              type: 'bar',
              data: {
                labels: ['Enero', 'Febrero', 'Marzo'],
                datasets: [{
                  label: 'Ventas',
                  data: [12, 19, 3]
                }]
              }
            });
            
            button.disabled = true;
            button.textContent = 'Gr√°fico Cargado';
          });
        </script>
      </body>
    </html>
    ```

    ### üì¶ Code Splitting Autom√°tico

    **Estructura de rutas**
    ```
    src/pages/
    ‚îú‚îÄ‚îÄ index.astro          # Bundle: home
    ‚îú‚îÄ‚îÄ about.astro          # Bundle: about
    ‚îú‚îÄ‚îÄ blog/
    ‚îÇ   ‚îú‚îÄ‚îÄ index.astro      # Bundle: blog-index
    ‚îÇ   ‚îî‚îÄ‚îÄ [slug].astro     # Bundle: blog-post
    ‚îî‚îÄ‚îÄ products/
        ‚îú‚îÄ‚îÄ index.astro      # Bundle: products-index
        ‚îî‚îÄ‚îÄ [id].astro       # Bundle: product-detail
    ```

    Astro autom√°ticamente crea bundles separados por ruta.

    ### üéØ Lazy Loading con Intersection Observer

    **Componente personalizado**
    ```astro
    ---
    // src/components/LazySection.astro
    const { id } = Astro.props;
    ---

    <div class="lazy-section" data-lazy-id={id}>
      <div class="placeholder">Cargando...</div>
      <div class="content" style="display: none;">
        <slot />
      </div>
    </div>

    <script>
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const section = entry.target;
            const placeholder = section.querySelector('.placeholder');
            const content = section.querySelector('.content');
            
            // Simular carga de contenido
            setTimeout(() => {
              placeholder.style.display = 'none';
              content.style.display = 'block';
            }, 500);
            
            observer.unobserve(section);
          }
        });
      }, {
        rootMargin: '50px'
      });

      document.querySelectorAll('.lazy-section').forEach(section => {
        observer.observe(section);
      });
    </script>
    ```

    **Uso**
    ```astro
    ---
    import LazySection from '../components/LazySection.astro';
    ---

    <html>
      <body>
        <h1>Contenido Principal</h1>
        <p>Contenido visible inmediatamente...</p>
        
        <LazySection id="section1">
          <h2>Secci√≥n Lazy 1</h2>
          <p>Este contenido se carga cuando es visible.</p>
        </LazySection>
        
        <LazySection id="section2">
          <h2>Secci√≥n Lazy 2</h2>
          <p>Este contenido tambi√©n es lazy.</p>
        </LazySection>
      </body>
    </html>
    ```

    ### üöÄ Prefetch de Rutas

    **Configuraci√≥n en `astro.config.mjs`**
    ```js
    import { defineConfig } from 'astro/config';

    export default defineConfig({
      prefetch: {
        prefetchAll: true,
        defaultStrategy: 'viewport'
      }
    });
    ```

    **Uso manual**
    ```astro
    <nav>
      <!-- Prefetch autom√°tico en hover -->
      <a href="/about" data-astro-prefetch>Acerca de</a>
      
      <!-- Prefetch inmediato -->
      <a href="/contact" data-astro-prefetch="load">Contacto</a>
      
      <!-- Prefetch cuando es visible -->
      <a href="/blog" data-astro-prefetch="viewport">Blog</a>
      
      <!-- Sin prefetch -->
      <a href="/admin">Admin</a>
    </nav>
    ```

    ### üìä Comparaci√≥n de Estrategias

    ```astro
    ---
    // src/pages/comparison.astro
    import HeavyComponent from '../components/HeavyComponent.jsx';
    ---

    <html>
      <body>
        <h1>Comparaci√≥n de Estrategias</h1>
        
        <!-- ‚ùå Malo: Todo carga inmediatamente -->
        <HeavyComponent client:load />
        
        <!-- ‚úÖ Mejor: Carga cuando es visible -->
        <HeavyComponent client:visible />
        
        <!-- ‚úÖ √ìptimo: Carga cuando el navegador est√° libre -->
        <HeavyComponent client:idle />
        
        <!-- ‚úÖ Condicional: Solo en m√≥vil -->
        <HeavyComponent client:media="(max-width: 768px)" />
        
        <!-- ‚ö° Solo cliente: No SSR -->
        <HeavyComponent client:only="react" />
      </body>
    </html>
    ```

    <Aside type="tip">
      üí° **Tip**: Usa `client:visible` para componentes below-the-fold y `client:idle` para widgets no cr√≠ticos. Esto puede reducir el JavaScript inicial hasta un 70%.
    </Aside>

    <Aside type="caution">
      ‚ö†Ô∏è **Advertencia**: El lazy loading puede causar CLS (Cumulative Layout Shift). Siempre reserva espacio con `width` y `height` en im√°genes.
    </Aside>

  </TabItem>
</Tabs>

---

## 9.2 Compresi√≥n y optimizaci√≥n de im√°genes

<Tabs>
  <TabItem label="üëî Parte te√≥rica">
    
    ### Compresi√≥n y Optimizaci√≥n de Im√°genes

    La **optimizaci√≥n de im√°genes** es crucial para el rendimiento web, ya que las im√°genes suelen representar el 50-70% del peso total de una p√°gina.

    #### üéØ Prop√≥sito

    - Reducir el tama√±o de archivos sin perder calidad perceptible
    - Mejorar tiempos de carga de la p√°gina
    - Reducir consumo de ancho de banda
    - Mejorar m√©tricas de rendimiento (LCP)
    - Optimizar para diferentes dispositivos y resoluciones

    #### üìã Formatos de Imagen Modernos

    **1. WebP**
    - Compresi√≥n superior a JPEG/PNG (25-35% m√°s peque√±o)
    - Soporta transparencia y animaci√≥n
    - Amplio soporte en navegadores modernos
    - Ideal para fotos y gr√°ficos

    **2. AVIF**
    - Compresi√≥n a√∫n mejor que WebP (50% m√°s peque√±o que JPEG)
    - Excelente calidad a tama√±os peque√±os
    - Soporte creciente en navegadores
    - Mejor para fotograf√≠as de alta calidad

    **3. SVG**
    - Formato vectorial escalable
    - Perfecto para iconos y logos
    - Tama√±o muy peque√±o
    - Se puede manipular con CSS/JS

    **4. Formatos tradicionales**
    - **JPEG**: Fotos, sin transparencia
    - **PNG**: Gr√°ficos con transparencia
    - **GIF**: Animaciones simples (obsoleto, usar WebP/AVIF)

    #### ‚öôÔ∏è T√©cnicas de Optimizaci√≥n

    **1. Compresi√≥n**
    - **Lossy**: Reduce calidad imperceptiblemente (JPEG, WebP)
    - **Lossless**: Sin p√©rdida de calidad (PNG, WebP lossless)
    - Herramientas: Sharp, ImageMagick, Squoosh

    **2. Responsive Images**
    - Diferentes tama√±os para diferentes dispositivos
    - Atributo `srcset` y `sizes`
    - Picture element para art direction
    - Ahorra ancho de banda en m√≥viles

    **3. Lazy Loading**
    - Cargar im√°genes cuando son visibles
    - Atributo `loading="lazy"`
    - Reduce carga inicial

    **4. Dimensiones Expl√≠citas**
    - Especificar `width` y `height`
    - Previene CLS (Cumulative Layout Shift)
    - Mejora experiencia de usuario

    #### üîß Integraci√≥n en Astro

    Astro proporciona componente `<Image>` integrado:
    - Optimizaci√≥n autom√°tica de im√°genes
    - Generaci√≥n de m√∫ltiples formatos
    - Responsive images autom√°tico
    - Lazy loading por defecto
    - Usa Sharp internamente

    #### üìä Comparaci√≥n de Formatos

    | Formato | Tama√±o | Calidad | Transparencia | Soporte |
    |---------|--------|---------|---------------|---------|
    | **JPEG** | 100% | Alta | ‚ùå | Universal |
    | **PNG** | 150% | Alta | ‚úÖ | Universal |
    | **WebP** | 70% | Alta | ‚úÖ | 95%+ |
    | **AVIF** | 50% | Muy Alta | ‚úÖ | 85%+ |
    | **SVG** | M√≠nimo | Escalable | ‚úÖ | Universal |

    #### üåü Mejores Pr√°cticas

    1. **Usar formatos modernos**: WebP/AVIF con fallback
    2. **Dimensiones correctas**: No cargar im√°genes m√°s grandes de lo necesario
    3. **Compresi√≥n adecuada**: Balance entre calidad y tama√±o
    4. **Lazy loading**: Para im√°genes below-the-fold
    5. **CDN**: Servir im√°genes desde CDN
    6. **Cach√©**: Headers de cach√© apropiados
    7. **Alt text**: Siempre incluir para accesibilidad

    #### üìà Impacto en Rendimiento

    - **LCP**: Mejora hasta 40% con im√°genes optimizadas
    - **Peso p√°gina**: Reducci√≥n de 50-70%
    - **Tiempo carga**: 30-50% m√°s r√°pido
    - **Datos m√≥viles**: Ahorro significativo para usuarios

  </TabItem>
  <TabItem label="üí° Ejemplos pr√°cticos">
    
    ### üñºÔ∏è Componente Image de Astro

    **Importaci√≥n y uso b√°sico**
    ```astro
    ---
    import { Image } from 'astro:assets';
    import heroImage from '../assets/hero.jpg';
    ---

    <Image 
      src={heroImage}
      alt="Imagen hero"
      width={1200}
      height={600}
      format="webp"
      quality={80}
    />
    ```

    ### üé® M√∫ltiples Formatos con Fallback

    ```astro
    ---
    import { Image, Picture } from 'astro:assets';
    import photo from '../assets/photo.jpg';
    ---

    <!-- Picture con m√∫ltiples formatos -->
    <Picture
      src={photo}
      formats={['avif', 'webp', 'jpeg']}
      alt="Foto optimizada"
      width={800}
      height={600}
      loading="lazy"
    />

    <!-- Genera:
    <picture>
      <source srcset="photo.avif" type="image/avif">
      <source srcset="photo.webp" type="image/webp">
      <img src="photo.jpg" alt="Foto optimizada">
    </picture>
    -->
    ```

    ### üì± Responsive Images

    ```astro
    ---
    import { Image } from 'astro:assets';
    import responsiveImg from '../assets/responsive.jpg';
    ---

    <Image 
      src={responsiveImg}
      alt="Imagen responsive"
      widths={[400, 800, 1200]}
      sizes="(max-width: 600px) 400px, (max-width: 900px) 800px, 1200px"
      format="webp"
    />

    <!-- Genera srcset autom√°ticamente -->
    ```

    ### üîß Configuraci√≥n de Optimizaci√≥n

    **`astro.config.mjs`**
    ```js
    import { defineConfig } from 'astro/config';

    export default defineConfig({
      image: {
        service: {
          entrypoint: 'astro/assets/services/sharp',
          config: {
            limitInputPixels: false,
          }
        },
        // Formatos de salida
        formats: ['avif', 'webp', 'jpeg'],
        // Calidad por defecto
        quality: 80,
      }
    });
    ```

    ### üéØ Galer√≠a Optimizada

    ```astro
    ---
    import { Image } from 'astro:assets';
    import { getCollection } from 'astro:content';

    const photos = await getCollection('gallery');
    ---

    <div class="gallery">
      {photos.map((photo, index) => (
        <Image 
          src={photo.data.image}
          alt={photo.data.title}
          width={400}
          height={300}
          format="webp"
          quality={80}
          loading={index < 6 ? 'eager' : 'lazy'}
          class="gallery-item"
        />
      ))}
    </div>

    <style>
      .gallery {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
        gap: 1rem;
      }
      
      .gallery-item {
        width: 100%;
        height: auto;
        border-radius: 8px;
      }
    </style>
    ```

    ### üåê Im√°genes Remotas

    ```astro
    ---
    import { Image } from 'astro:assets';

    const remoteImage = 'https://example.com/image.jpg';
    ---

    <!-- Imagen remota (requiere configuraci√≥n) -->
    <Image 
      src={remoteImage}
      alt="Imagen remota"
      width={800}
      height={600}
      format="webp"
    />
    ```

    **Configuraci√≥n para im√°genes remotas**
    ```js
    // astro.config.mjs
    export default defineConfig({
      image: {
        domains: ['example.com', 'cdn.example.com'],
        remotePatterns: [
          {
            protocol: 'https',
            hostname: '**.example.com',
          }
        ]
      }
    });
    ```

    ### üé® Optimizaci√≥n Manual con Sharp

    **Script de optimizaci√≥n**
    ```javascript
    // scripts/optimize-images.js
    import sharp from 'sharp';
    import { readdir } from 'fs/promises';
    import { join } from 'path';

    const inputDir = './src/assets/original';
    const outputDir = './src/assets/optimized';

    async function optimizeImages() {
      const files = await readdir(inputDir);
      
      for (const file of files) {
        if (!file.match(/\.(jpg|jpeg|png)$/i)) continue;
        
        const inputPath = join(inputDir, file);
        const outputName = file.replace(/\.(jpg|jpeg|png)$/i, '');
        
        // WebP
        await sharp(inputPath)
          .webp({ quality: 80 })
          .toFile(join(outputDir, `${outputName}.webp`));
        
        // AVIF
        await sharp(inputPath)
          .avif({ quality: 70 })
          .toFile(join(outputDir, `${outputName}.avif`));
        
        // JPEG optimizado
        await sharp(inputPath)
          .jpeg({ quality: 85, progressive: true })
          .toFile(join(outputDir, `${outputName}.jpg`));
        
        console.log(`‚úÖ Optimizado: ${file}`);
      }
    }

    optimizeImages();
    ```

    ### üìä Placeholder con Blur

    ```astro
    ---
    import { Image } from 'astro:assets';
    import photo from '../assets/photo.jpg';
    ---

    <div class="image-container">
      <Image 
        src={photo}
        alt="Foto con blur placeholder"
        width={800}
        height={600}
        format="webp"
        loading="lazy"
        class="blur-load"
      />
    </div>

    <style>
      .image-container {
        position: relative;
        background: linear-gradient(to bottom, #f0f0f0, #e0e0e0);
      }
      
      .blur-load {
        animation: fadeIn 0.5s ease-in;
      }
      
      @keyframes fadeIn {
        from {
          opacity: 0;
          filter: blur(10px);
        }
        to {
          opacity: 1;
          filter: blur(0);
        }
      }
    </style>
    ```

    ### üîç Art Direction con Picture

    ```astro
    ---
    import { Picture } from 'astro:assets';
    import desktopImg from '../assets/hero-desktop.jpg';
    import mobileImg from '../assets/hero-mobile.jpg';
    ---

    <Picture
      src={desktopImg}
      alt="Hero image"
      formats={['avif', 'webp']}
      width={1200}
      height={600}
      pictureAttributes={{
        media: '(min-width: 768px)'
      }}
    />

    <Picture
      src={mobileImg}
      alt="Hero image mobile"
      formats={['avif', 'webp']}
      width={600}
      height={800}
      pictureAttributes={{
        media: '(max-width: 767px)'
      }}
    />
    ```

    ### üìã Checklist de Optimizaci√≥n

    <Steps>

    1. **Usar formatos modernos**
       - WebP para compatibilidad amplia
       - AVIF para mejor compresi√≥n
       - Fallback a JPEG/PNG

    2. **Dimensiones apropiadas**
       - No cargar im√°genes m√°s grandes que el contenedor
       - Usar responsive images con srcset

    3. **Compresi√≥n adecuada**
       - Calidad 80-85 para fotos
       - Calidad 90+ para im√°genes con texto

    4. **Lazy loading**
       - `loading="lazy"` para im√°genes below-the-fold
       - `loading="eager"` solo para hero images

    5. **Especificar dimensiones**
       - Siempre incluir width y height
       - Previene CLS

    6. **Alt text descriptivo**
       - Para accesibilidad y SEO
       - Describir el contenido de la imagen

    </Steps>

    <Aside type="tip">
      üí° **Tip**: Usa herramientas como Squoosh.app para experimentar con diferentes formatos y niveles de compresi√≥n antes de implementar.
    </Aside>

    <Aside type="note">
      üìù **Nota**: El componente `<Image>` de Astro genera autom√°ticamente m√∫ltiples tama√±os y formatos durante el build, optimizando para todos los dispositivos.
    </Aside>

  </TabItem>
</Tabs>

---

## 9.3 An√°lisis de rendimiento con Lighthouse

<Tabs>
  <TabItem label="üëî Parte te√≥rica">
    
    ### An√°lisis de Rendimiento con Lighthouse

    **Lighthouse** es una herramienta automatizada de c√≥digo abierto desarrollada por Google para mejorar la calidad de las p√°ginas web mediante auditor√≠as de rendimiento, accesibilidad, SEO y mejores pr√°cticas.

    #### üéØ Prop√≥sito

    - Medir rendimiento real de p√°ginas web
    - Identificar problemas y oportunidades de mejora
    - Proporcionar recomendaciones accionables
    - Monitorear Core Web Vitals
    - Validar mejores pr√°cticas web

    #### üìä Categor√≠as de Auditor√≠a

    **1. Performance (Rendimiento)**
    - M√©tricas de velocidad de carga
    - Core Web Vitals (FCP, LCP, CLS, etc.)
    - Oportunidades de optimizaci√≥n
    - Diagn√≥sticos de problemas

    **2. Accessibility (Accesibilidad)**
    - Contraste de colores
    - Etiquetas ARIA
    - Navegaci√≥n por teclado
    - Textos alternativos

    **3. Best Practices (Mejores Pr√°cticas)**
    - HTTPS
    - Errores de consola
    - Librer√≠as vulnerables
    - Uso de APIs modernas

    **4. SEO**
    - Meta tags
    - Estructura de contenido
    - Robots.txt y sitemap
    - Mobile-friendly

    **5. PWA (Progressive Web App)**
    - Service workers
    - Manifest
    - Instalabilidad
    - Offline functionality

    #### üìà Core Web Vitals

    **M√©tricas principales de Google**

    | M√©trica | Nombre | Objetivo | Mide |
    |---------|--------|----------|------|
    | **LCP** | Largest Contentful Paint | < 2.5s | Velocidad de carga |
    | **FID** | First Input Delay | < 100ms | Interactividad |
    | **CLS** | Cumulative Layout Shift | < 0.1 | Estabilidad visual |
    | **FCP** | First Contentful Paint | < 1.8s | Renderizado inicial |
    | **TTI** | Time to Interactive | < 3.8s | Interactividad completa |
    | **TBT** | Total Blocking Time | < 200ms | Bloqueo del hilo principal |

    #### ‚öôÔ∏è C√≥mo Funciona Lighthouse

    1. **Navegaci√≥n**: Carga la p√°gina en Chrome
    2. **Auditor√≠a**: Ejecuta tests automatizados
    3. **Medici√≥n**: Recopila m√©tricas de rendimiento
    4. **An√°lisis**: Eval√∫a contra mejores pr√°cticas
    5. **Reporte**: Genera informe con puntuaciones y recomendaciones

    #### üîß Formas de Ejecutar Lighthouse

    **1. Chrome DevTools**
    - Integrado en el navegador
    - F√°cil de usar
    - Ideal para desarrollo

    **2. CLI (Command Line)**
    - Automatizaci√≥n
    - CI/CD integration
    - Reportes program√°ticos

    **3. PageSpeed Insights**
    - Interfaz web de Google
    - Datos de campo reales (CrUX)
    - No requiere instalaci√≥n

    **4. Lighthouse CI**
    - Integraci√≥n continua
    - Monitoreo autom√°tico
    - Prevenci√≥n de regresiones

    #### üåü Mejores Pr√°cticas

    1. **Ejecutar en modo inc√≥gnito**: Evitar extensiones
    2. **Simular condiciones reales**: Throttling de red
    3. **M√∫ltiples ejecuciones**: Promediar resultados
    4. **Ambiente consistente**: Mismas condiciones
    5. **Priorizar Core Web Vitals**: Impacto en SEO
    6. **Monitoreo continuo**: CI/CD integration

    #### üìã Interpretaci√≥n de Puntuaciones

    | Rango | Color | Significado |
    |-------|-------|-------------|
    | **90-100** | üü¢ Verde | Excelente |
    | **50-89** | üü† Naranja | Necesita mejora |
    | **0-49** | üî¥ Rojo | Pobre |

    #### üéØ Optimizaciones Comunes

    **Para mejorar Performance:**
    - Minimizar JavaScript
    - Optimizar im√°genes
    - Lazy loading
    - Cach√© efectivo
    - CDN

    **Para mejorar Accessibility:**
    - Alt text en im√°genes
    - Contraste adecuado
    - Labels en formularios
    - Estructura sem√°ntica

    **Para mejorar SEO:**
    - Meta descriptions
    - T√≠tulos √∫nicos
    - Sitemap
    - Mobile-friendly

  </TabItem>
  <TabItem label="üí° Ejemplos pr√°cticos">
    
    ### üîç Ejecutar Lighthouse en Chrome DevTools

    **Pasos:**
    
    <Steps>

    1. **Abrir DevTools**
       - Presiona `F12` o `Ctrl+Shift+I` (Windows/Linux)
       - O `Cmd+Option+I` (Mac)

    2. **Ir a pesta√±a Lighthouse**
       - Busca la pesta√±a "Lighthouse" en DevTools
       - Si no est√° visible, haz clic en `>>` para m√°s opciones

    3. **Configurar auditor√≠a**
       - Selecciona categor√≠as (Performance, Accessibility, etc.)
       - Elige dispositivo (Mobile o Desktop)
       - Configura throttling

    4. **Generar reporte**
       - Clic en "Analyze page load"
       - Espera a que termine el an√°lisis

    5. **Revisar resultados**
       - Puntuaciones por categor√≠a
       - M√©tricas detalladas
       - Oportunidades de mejora

    </Steps>

    ### üíª Lighthouse CLI

    **Instalaci√≥n**
    ```bash
    npm install -g lighthouse
    ```

    **Uso b√°sico**
    ```bash
    # Auditor√≠a completa
    lighthouse https://misite.com

    # Solo performance
    lighthouse https://misite.com --only-categories=performance

    # Modo m√≥vil
    lighthouse https://misite.com --preset=mobile

    # Guardar reporte HTML
    lighthouse https://misite.com --output=html --output-path=./report.html

    # M√∫ltiples formatos
    lighthouse https://misite.com --output=json --output=html --output-path=./reports/
    ```

    **Script de auditor√≠a automatizada**
    ```javascript
    // scripts/lighthouse-audit.js
    import lighthouse from 'lighthouse';
    import * as chromeLauncher from 'chrome-launcher';
    import { writeFileSync } from 'fs';

    async function runLighthouse(url) {
      // Lanzar Chrome
      const chrome = await chromeLauncher.launch({
        chromeFlags: ['--headless']
      });

      // Configuraci√≥n
      const options = {
        logLevel: 'info',
        output: 'html',
        onlyCategories: ['performance', 'accessibility', 'seo'],
        port: chrome.port
      };

      // Ejecutar auditor√≠a
      const runnerResult = await lighthouse(url, options);

      // Guardar reporte
      const reportHtml = runnerResult.report;
      writeFileSync('lighthouse-report.html', reportHtml);

      // Mostrar puntuaciones
      console.log('Puntuaciones:');
      console.log('Performance:', runnerResult.lhr.categories.performance.score * 100);
      console.log('Accessibility:', runnerResult.lhr.categories.accessibility.score * 100);
      console.log('SEO:', runnerResult.lhr.categories.seo.score * 100);

      // Cerrar Chrome
      await chrome.kill();
    }

    runLighthouse('https://misite.com');
    ```

    ### üöÄ Lighthouse CI

    **Instalaci√≥n**
    ```bash
    npm install -g @lhci/cli
    ```

    **Configuraci√≥n `lighthouserc.json`**
    ```json
    {
      "ci": {
        "collect": {
          "startServerCommand": "npm run preview",
          "url": [
            "http://localhost:4321/",
            "http://localhost:4321/blog",
            "http://localhost:4321/about"
          ],
          "numberOfRuns": 3
        },
        "assert": {
          "preset": "lighthouse:recommended",
          "assertions": {
            "categories:performance": ["error", {"minScore": 0.9}],
            "categories:accessibility": ["error", {"minScore": 0.9}],
            "categories:seo": ["error", {"minScore": 0.9}],
            "first-contentful-paint": ["error", {"maxNumericValue": 2000}],
            "largest-contentful-paint": ["error", {"maxNumericValue": 2500}],
            "cumulative-layout-shift": ["error", {"maxNumericValue": 0.1}]
          }
        },
        "upload": {
          "target": "temporary-public-storage"
        }
      }
    }
    ```

    **Scripts en `package.json`**
    ```json
    {
      "scripts": {
        "lhci:collect": "lhci collect",
        "lhci:assert": "lhci assert",
        "lhci:upload": "lhci upload",
        "lhci": "npm run lhci:collect && npm run lhci:assert && npm run lhci:upload"
      }
    }
    ```

    **Ejecutar**
    ```bash
    npm run lhci
    ```

    ### üîÑ GitHub Actions con Lighthouse CI

    **`.github/workflows/lighthouse.yml`**
    ```yaml
    name: Lighthouse CI

    on:
      push:
        branches: [main]
      pull_request:
        branches: [main]

    jobs:
      lighthouse:
        runs-on: ubuntu-latest
        steps:
          - uses: actions/checkout@v3
          
          - name: Setup Node.js
            uses: actions/setup-node@v3
            with:
              node-version: '18'
          
          - name: Install dependencies
            run: npm ci
          
          - name: Build
            run: npm run build
          
          - name: Run Lighthouse CI
            run: |
              npm install -g @lhci/cli
              lhci autorun
            env:
              LHCI_GITHUB_APP_TOKEN: ${{ secrets.LHCI_GITHUB_APP_TOKEN }}
    ```

    ### üìä An√°lisis de Resultados

    **Interpretar m√©tricas**
    ```javascript
    // scripts/analyze-lighthouse.js
    import { readFileSync } from 'fs';

    const report = JSON.parse(readFileSync('./lighthouse-report.json', 'utf8'));

    // Puntuaciones
    const scores = {
      performance: report.categories.performance.score * 100,
      accessibility: report.categories.accessibility.score * 100,
      bestPractices: report.categories['best-practices'].score * 100,
      seo: report.categories.seo.score * 100
    };

    console.log('üìä Puntuaciones:');
    Object.entries(scores).forEach(([category, score]) => {
      const emoji = score >= 90 ? 'üü¢' : score >= 50 ? 'üü†' : 'üî¥';
      console.log(`${emoji} ${category}: ${score.toFixed(0)}`);
    });

    // Core Web Vitals
    const audits = report.audits;
    console.log('\n‚ö° Core Web Vitals:');
    console.log(`LCP: ${audits['largest-contentful-paint'].displayValue}`);
    console.log(`FID: ${audits['max-potential-fid']?.displayValue || 'N/A'}`);
    console.log(`CLS: ${audits['cumulative-layout-shift'].displayValue}`);

    // Oportunidades
    console.log('\nüí° Principales oportunidades:');
    const opportunities = Object.values(audits)
      .filter(audit => audit.details?.type === 'opportunity')
      .sort((a, b) => b.numericValue - a.numericValue)
      .slice(0, 5);

    opportunities.forEach(opp => {
      console.log(`- ${opp.title}: ${opp.displayValue}`);
    });
    ```

    ### üéØ Optimizaciones Basadas en Lighthouse

    **Ejemplo de mejoras**
    ```astro
    ---
    // src/pages/optimized.astro
    import { Image } from 'astro:assets';
    import heroImg from '../assets/hero.jpg';
    ---

    <!DOCTYPE html>
    <html lang="es">
      <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        
        <!-- SEO: T√≠tulos y descripciones -->
        <title>Mi Sitio Optimizado</title>
        <meta name="description" content="Sitio web optimizado para rendimiento" />
        
        <!-- Performance: Preconnect a recursos externos -->
        <link rel="preconnect" href="https://fonts.googleapis.com" />
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
        
        <!-- Performance: Preload de recursos cr√≠ticos -->
        <link rel="preload" href="/fonts/main.woff2" as="font" type="font/woff2" crossorigin />
        
        <!-- Best Practices: Favicon -->
        <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
      </head>
      <body>
        <!-- Accessibility: Estructura sem√°ntica -->
        <header>
          <nav aria-label="Navegaci√≥n principal">
            <a href="/">Inicio</a>
            <a href="/about">Acerca de</a>
          </nav>
        </header>

        <main>
          <!-- Performance: Imagen optimizada -->
          <Image 
            src={heroImg}
            alt="Imagen hero descriptiva"
            width={1200}
            height={600}
            format="webp"
            loading="eager"
          />
          
          <h1>Contenido Principal</h1>
          <p>Texto del contenido...</p>
        </main>

        <footer>
          <p>¬© 2024 Mi Sitio</p>
        </footer>

        <!-- Performance: Scripts diferidos -->
        <script src="/js/analytics.js" defer></script>
      </body>
    </html>
    ```

    ### üìã Checklist de Optimizaci√≥n

    **Basado en recomendaciones de Lighthouse:**

    <Steps>

    1. **Performance**
       - ‚úÖ Im√°genes optimizadas (WebP/AVIF)
       - ‚úÖ Lazy loading implementado
       - ‚úÖ Minificaci√≥n de CSS/JS
       - ‚úÖ Cach√© configurado
       - ‚úÖ CDN para recursos est√°ticos

    2. **Accessibility**
       - ‚úÖ Alt text en todas las im√°genes
       - ‚úÖ Contraste de colores > 4.5:1
       - ‚úÖ Labels en formularios
       - ‚úÖ Navegaci√≥n por teclado funcional
       - ‚úÖ ARIA labels donde necesario

    3. **SEO**
       - ‚úÖ Meta description √∫nica
       - ‚úÖ T√≠tulos descriptivos
       - ‚úÖ Sitemap.xml
       - ‚úÖ Robots.txt
       - ‚úÖ Mobile-friendly

    4. **Best Practices**
       - ‚úÖ HTTPS habilitado
       - ‚úÖ Sin errores de consola
       - ‚úÖ Librer√≠as actualizadas
       - ‚úÖ Sin vulnerabilidades conocidas

    </Steps>

    <Aside type="tip">
      üí° **Tip**: Ejecuta Lighthouse regularmente durante el desarrollo para detectar regresiones de rendimiento temprano. Integra en tu CI/CD para prevenir degradaciones.
    </Aside>

    <Aside type="note">
      üìù **Nota**: Las puntuaciones de Lighthouse pueden variar entre ejecuciones debido a condiciones de red y sistema. Siempre ejecuta m√∫ltiples veces y promedia los resultados.
    </Aside>

    <Aside type="caution">
      ‚ö†Ô∏è **Advertencia**: Una puntuaci√≥n de 100 en Lighthouse no garantiza una experiencia perfecta. Usa tambi√©n datos de usuarios reales (RUM) para validar el rendimiento.
    </Aside>

  </TabItem>
</Tabs>
