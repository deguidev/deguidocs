---
title: 11. ProgramaciÃ³n Orientada a Objetos
description: Clases, objetos, atributos, mÃ©todos, herencia y encapsulamiento en Python
---

import { Code } from '@astrojs/starlight/components';
import { Tabs, TabItem } from '@astrojs/starlight/components';
import { Badge } from '@astrojs/starlight/components';
import { Aside } from '@astrojs/starlight/components';
import { Steps } from '@astrojs/starlight/components';

## ğŸ¯ 11.1 Â¿QuÃ© es la POO y por quÃ© se usa?

<Tabs>
<TabItem label="ğŸ‘” Parte TeÃ³rica">

### Concepto de POO

La **ProgramaciÃ³n Orientada a Objetos** (POO) es un paradigma de programaciÃ³n que organiza el cÃ³digo en torno a "objetos" que representan entidades del mundo real o conceptos abstractos. Cada objeto combina datos (atributos) y comportamientos (mÃ©todos).

### Principios fundamentales

**ğŸ”¹ AbstracciÃ³n**: Modelar entidades del mundo real en cÃ³digo  
**ğŸ”¹ Encapsulamiento**: Ocultar detalles internos, exponer solo lo necesario  
**ğŸ”¹ Herencia**: Crear nuevas clases basadas en clases existentes  
**ğŸ”¹ Polimorfismo**: Objetos de diferentes clases pueden responder a la misma interfaz  

### Ventajas de la POO

- **ReutilizaciÃ³n**: CÃ³digo modular y reutilizable
- **Mantenibilidad**: Cambios localizados, fÃ¡cil de actualizar
- **OrganizaciÃ³n**: Estructura clara y lÃ³gica
- **Modelado natural**: Representa conceptos del mundo real
- **Escalabilidad**: Facilita el crecimiento de proyectos

### Conceptos clave

**Clase**: Plantilla o molde para crear objetos  
**Objeto**: Instancia especÃ­fica de una clase  
**Atributo**: Datos que describe el objeto  
**MÃ©todo**: Funciones que definen el comportamiento del objeto  

</TabItem>

<TabItem label="ğŸ’¡ Ejemplos PrÃ¡cticos">

### POO vs ProgramaciÃ³n Procedural

<Code code={`# PROGRAMACIÃ“N PROCEDURAL (sin POO)
nombre_perro = "Max"
edad_perro = 3
raza_perro = "Labrador"

def ladrar(nombre):
    print(f"{nombre} dice: Â¡Guau!")

ladrar(nombre_perro)

# PROGRAMACIÃ“N ORIENTADA A OBJETOS
class Perro:
    def __init__(self, nombre, edad, raza):
        self.nombre = nombre
        self.edad = edad
        self.raza = raza
    
    def ladrar(self):
        print(f"{self.nombre} dice: Â¡Guau!")

# Crear objeto
mi_perro = Perro("Max", 3, "Labrador")
mi_perro.ladrar()  # Max dice: Â¡Guau!
`} lang="python" title="POO vs Procedural" />

</TabItem>
</Tabs>

---

## ğŸ—ï¸ 11.2 Crear clases y objetos en Python

<Tabs>
<TabItem label="ğŸ‘” Parte TeÃ³rica">

### Definir una clase

**Sintaxis**:
<Code code={`class NombreClase:
    # Cuerpo de la clase
    pass`} lang="python" title="Definir una clase" />

### Crear objetos (instancias)

**Sintaxis**:
<Code code={`objeto = NombreClase()`} lang="python" title="Crear objetos (instancias)" />

### Convenciones

**ğŸ”¹ Nombres de clases**: PascalCase (primera letra de cada palabra en mayÃºscula)  
**ğŸ”¹ Nombres de objetos**: snake_case (minÃºsculas con guiones bajos)  
**ğŸ”¹ IndentaciÃ³n**: El cuerpo de la clase debe estar indentado  

</TabItem>

<TabItem label="ğŸ’¡ Ejemplos PrÃ¡cticos">

### Clase bÃ¡sica

<Code code={`# Definir una clase simple
class Persona:
    pass

# Crear objetos (instancias)
persona1 = Persona()
persona2 = Persona()

print(type(persona1))  # <class '__main__.Persona'>
print(persona1 == persona2)  # False (objetos diferentes)`} lang="python" title="Clase bÃ¡sica" />

</TabItem>
</Tabs>

---

## ğŸ“Š 11.3 Propiedades (atributos) y comportamientos (mÃ©todos)

<Tabs>
<TabItem label="ğŸ‘” Parte TeÃ³rica">

### Atributos (propiedades)

Los **atributos** son variables que pertenecen a un objeto y almacenan su estado.

### MÃ©todos (comportamientos)

Los **mÃ©todos** son funciones definidas dentro de una clase que describen el comportamiento del objeto. El primer parÃ¡metro siempre es self.

</TabItem>

<TabItem label="ğŸ’¡ Ejemplos PrÃ¡cticos">

### Atributos y mÃ©todos

<Code code={`class Perro:
    def __init__(self, nombre, raza):
        self.nombre = nombre  # Atributo
        self.raza = raza      # Atributo
    
    def ladrar(self):  # MÃ©todo
        print(f"{self.nombre} dice: Â¡Guau!")
    
    def presentarse(self):  # MÃ©todo
        print(f"Hola, soy {self.nombre} y soy un {self.raza}")

mi_perro = Perro("Max", "Labrador")
mi_perro.ladrar()        # Max dice: Â¡Guau!
mi_perro.presentarse()   # Hola, soy Max y soy un Labrador`} lang="python" title="Atributos y mÃ©todos" />

</TabItem>
</Tabs>

---

## ğŸ¬ 11.4 El mÃ©todo __init__() y su funciÃ³n

<Tabs>
<TabItem label="ğŸ‘” Parte TeÃ³rica">

### Concepto de __init__()

El mÃ©todo **`__init__()`** es el constructor de la clase. Se ejecuta automÃ¡ticamente cuando se crea un nuevo objeto para inicializar sus atributos.

### Sintaxis

<Code code={`def __init__(self, parametros):
    self.atributo = valor`} lang="python" title="__init__()" />

</TabItem>

<TabItem label="ğŸ’¡ Ejemplos PrÃ¡cticos">

### __init__() bÃ¡sico

<Code code={`class Persona:
    def __init__(self, nombre, edad):
        self.nombre = nombre
        self.edad = edad

persona = Persona("Ana", 25)
print(f"{persona.nombre} tiene {persona.edad} aÃ±os")`} lang="python" title="__init__()" />

### Con valores por defecto

<Code code={`class CuentaBancaria:
    def __init__(self, titular, saldo=0):
        self.titular = titular
        self.saldo = saldo
    
    def mostrar_saldo(self):
        print(f"Saldo de {self.titular}: {self.saldo} USD")

cuenta1 = CuentaBancaria("Ana", 1000)
cuenta2 = CuentaBancaria("Carlos")  # saldo = 0
cuenta1.mostrar_saldo()  # Saldo de Ana: 1000 USD
`} lang="python" title="Valores por defecto" />

</TabItem>
</Tabs>

---

## ğŸ”’ 11.5 Encapsulamiento y uso de self

<Tabs>
<TabItem label="ğŸ‘” Parte TeÃ³rica">

### self

**self** es una referencia al objeto actual. Permite acceder a atributos y mÃ©todos del objeto desde dentro de la clase.

### Encapsulamiento

El **encapsulamiento** oculta los detalles internos. En Python:
- **pÃºblico**: `atributo`
- **protegido**: `_atributo` (convenciÃ³n)
- **privado**: `__atributo` (name mangling)

</TabItem>

<TabItem label="ğŸ’¡ Ejemplos PrÃ¡cticos">

### Uso de self

<Code code={`class Rectangulo:
    def __init__(self, base, altura):
        self.base = base
        self.altura = altura
    
    def calcular_area(self):
        return self.base * self.altura
    
    def mostrar_info(self):
        area = self.calcular_area()  # Usar self para llamar mÃ©todo
        print(f"Ãrea: {area}")

rect = Rectangulo(5, 3)
rect.mostrar_info()  # Ãrea: 15
`} lang="python" title="self" />

### Encapsulamiento

<Code code={`class CuentaBancaria:
    def __init__(self, titular, saldo_inicial):
        self.titular = titular
        self.__saldo = saldo_inicial  # Privado
    
    def depositar(self, cantidad):
        if cantidad > 0:
            self.__saldo += cantidad
    
    def obtener_saldo(self):
        return self.__saldo

cuenta = CuentaBancaria("Ana", 1000)
cuenta.depositar(500)
print(cuenta.obtener_saldo())  # 1500
`} lang="python" title="Encapsulamiento" />

</TabItem>
</Tabs>

---

## ğŸ‘¨â€ğŸ‘©â€ğŸ‘§ 11.6 Herencia y clases hijas

<Tabs>
<TabItem label="ğŸ‘” Parte TeÃ³rica">

### Concepto de herencia

La **herencia** permite crear nuevas clases basadas en clases existentes, heredando sus atributos y mÃ©todos.

**Sintaxis**:
<Code code={`class ClaseHija(ClasePadre):
    # CÃ³digo adicional`} lang="python" title="Herencia" />

### super()

La funciÃ³n **super()** permite acceder a mÃ©todos de la clase padre.

</TabItem>

<TabItem label="ğŸ’¡ Ejemplos PrÃ¡cticos">

### Herencia bÃ¡sica

<Code code={`class Animal:
    def __init__(self, nombre):
        self.nombre = nombre
    
    def hacer_sonido(self):
        print("El animal hace un sonido")

class Perro(Animal):
    def hacer_sonido(self):
        print(f"{self.nombre} dice: Â¡Guau!")

class Gato(Animal):
    def hacer_sonido(self):
        print(f"{self.nombre} dice: Â¡Miau!")

perro = Perro("Max")
gato = Gato("Luna")
perro.hacer_sonido()  # Max dice: Â¡Guau!
gato.hacer_sonido()   # Luna dice: Â¡Miau!
`} lang="python" title="Herencia" />

### Usar super()

<Code code={`class Vehiculo:
    def __init__(self, marca, modelo):
        self.marca = marca
        self.modelo = modelo

class Coche(Vehiculo):
    def __init__(self, marca, modelo, puertas):
        super().__init__(marca, modelo)
        self.puertas = puertas

coche = Coche("Toyota", "Corolla", 4)
print(f"{coche.marca} {coche.modelo} - {coche.puertas} puertas")`} lang="python" title="super()" />

</TabItem>
</Tabs>

---

## âš™ï¸ 11.7 MÃ©todos especiales: __str__(), __len__(), etc.

<Tabs>
<TabItem label="ğŸ‘” Parte TeÃ³rica">

### MÃ©todos mÃ¡gicos

Los **mÃ©todos especiales** permiten personalizar el comportamiento de los objetos.

**`__str__()`**: RepresentaciÃ³n legible (para print)  
**`__len__()`**: Longitud (para len())  
**`__eq__()`**: Igualdad (para ==)  
**`__add__()`**: Suma (para +)  

</TabItem>

<TabItem label="ğŸ’¡ Ejemplos PrÃ¡cticos">

### __str__()

<Code code={`class Libro:
    def __init__(self, titulo, autor):
        self.titulo = titulo
        self.autor = autor
    
    def __str__(self):
        return f'"{self.titulo}" por {self.autor}'

libro = Libro("Python 101", "Ana GarcÃ­a")
print(libro)  # "Python 101" por Ana GarcÃ­a
`} lang="python" title="__str__()" />

### __len__()

<Code code={`class Playlist:
    def __init__(self, nombre):
        self.nombre = nombre
        self.canciones = []
    
    def agregar(self, cancion):
        self.canciones.append(cancion)
    
    def __len__(self):
        return len(self.canciones)

playlist = Playlist("Favoritas")
playlist.agregar("CanciÃ³n 1")
playlist.agregar("CanciÃ³n 2")
print(len(playlist))  # 2
`} lang="python" title="__len__()" />

</TabItem>
</Tabs>

---

## ğŸ“ 11.8 Buenas prÃ¡cticas al diseÃ±ar clases

<Tabs>
<TabItem label="ğŸ‘” Parte TeÃ³rica">

### Principios de diseÃ±o

**ğŸ”¹ Responsabilidad Ãºnica**: Una clase debe tener un solo propÃ³sito  
**ğŸ”¹ Encapsulamiento**: Ocultar detalles de implementaciÃ³n  
**ğŸ”¹ Nombres descriptivos**: Clases y mÃ©todos con nombres claros  
**ğŸ”¹ DocumentaciÃ³n**: Usar docstrings  

</TabItem>

<TabItem label="ğŸ’¡ Ejemplos PrÃ¡cticos">

### Clase bien diseÃ±ada

<Code code={`class CuentaBancaria:
    """Representa una cuenta bancaria con operaciones bÃ¡sicas."""
    
    def __init__(self, titular, saldo_inicial=0):
        """Inicializa una nueva cuenta bancaria."""
        self.titular = titular
        self.__saldo = saldo_inicial
    
    def depositar(self, cantidad):
        """Deposita dinero en la cuenta."""
        if cantidad > 0:
            self.__saldo += cantidad
            return True
        return False
    
    def retirar(self, cantidad):
        """Retira dinero de la cuenta."""
        if 0 < cantidad <= self.__saldo:
            self.__saldo -= cantidad
            return True
        return False
    
    def obtener_saldo(self):
        """Retorna el saldo actual."""
        return self.__saldo
    
    def __str__(self):
        return f"Cuenta de {self.titular}: {self.__saldo:.2f} USD"

cuenta = CuentaBancaria("Ana GarcÃ­a", 1000)
cuenta.depositar(500)
print(cuenta)  # Cuenta de Ana GarcÃ­a: 1500.00 USD`} lang="python" title="Clase bien diseÃ±ada" />

<Aside type="tip" title="ğŸ’¡ Reglas de oro">
1. **Una clase, un propÃ³sito**: No mezclar responsabilidades
2. **Encapsular datos**: Usar atributos privados con mÃ©todos de acceso
3. **Documentar todo**: Docstrings claros y concisos
4. **Nombres descriptivos**: Que expliquen quÃ© hace la clase/mÃ©todo
5. **MÃ©todos pequeÃ±os**: Funciones cortas y especÃ­ficas
6. **Herencia con moderaciÃ³n**: Solo cuando hay relaciÃ³n "es-un"
7. **Implementar __str__()**: Para representaciÃ³n legible
8. **Validar en __init__()**: Asegurar estado vÃ¡lido desde el inicio
</Aside>

</TabItem>
</Tabs>

---

## ğŸ¯ Resumen de la lecciÃ³n

<Aside type="tip" title="ğŸ“š Lo que aprendiste">
En esta lecciÃ³n sobre ProgramaciÃ³n Orientada a Objetos has aprendido:

âœ… **POO**: Paradigma que organiza cÃ³digo en objetos con atributos y mÃ©todos  
âœ… **Clases y objetos**: Plantillas y sus instancias especÃ­ficas  
âœ… **Atributos y mÃ©todos**: Propiedades y comportamientos de objetos  
âœ… **__init__()**: Constructor para inicializar objetos  
âœ… **Encapsulamiento y self**: Ocultar detalles, usar self para referenciar el objeto  
âœ… **Herencia**: Crear clases hijas que heredan de clases padres  
âœ… **MÃ©todos especiales**: __str__(), __len__(), __eq__() para personalizar comportamiento  
âœ… **Buenas prÃ¡cticas**: Responsabilidad Ãºnica, encapsulamiento, documentaciÃ³n  

**PrÃ³ximo paso**: Ahora tienes las bases de POO para crear aplicaciones mÃ¡s complejas y organizadas.
</Aside>
