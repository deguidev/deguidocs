---
title: 11. Programación Orientada a Objetos
description: Clases, objetos, atributos, métodos, herencia y encapsulamiento en Python
---

import { Code } from '@astrojs/starlight/components';
import { Tabs, TabItem } from '@astrojs/starlight/components';
import { Badge } from '@astrojs/starlight/components';
import { Aside } from '@astrojs/starlight/components';
import { Steps } from '@astrojs/starlight/components';

## 🎯 11.1 ¿Qué es la POO y por qué se usa?

<Tabs>
<TabItem label="👔 Parte Teórica">

### Concepto de POO

La **Programación Orientada a Objetos** (POO) es un paradigma de programación que organiza el código en torno a "objetos" que representan entidades del mundo real o conceptos abstractos. Cada objeto combina datos (atributos) y comportamientos (métodos).

### Principios fundamentales

**🔹 Abstracción**: Modelar entidades del mundo real en código  
**🔹 Encapsulamiento**: Ocultar detalles internos, exponer solo lo necesario  
**🔹 Herencia**: Crear nuevas clases basadas en clases existentes  
**🔹 Polimorfismo**: Objetos de diferentes clases pueden responder a la misma interfaz  

### Ventajas de la POO

- **Reutilización**: Código modular y reutilizable
- **Mantenibilidad**: Cambios localizados, fácil de actualizar
- **Organización**: Estructura clara y lógica
- **Modelado natural**: Representa conceptos del mundo real
- **Escalabilidad**: Facilita el crecimiento de proyectos

### Conceptos clave

**Clase**: Plantilla o molde para crear objetos  
**Objeto**: Instancia específica de una clase  
**Atributo**: Datos que describe el objeto  
**Método**: Funciones que definen el comportamiento del objeto  

</TabItem>

<TabItem label="💡 Ejemplos Prácticos">

### POO vs Programación Procedural

<Code code={`# PROGRAMACIÓN PROCEDURAL (sin POO)
nombre_perro = "Max"
edad_perro = 3
raza_perro = "Labrador"

def ladrar(nombre):
    print(f"{nombre} dice: ¡Guau!")

ladrar(nombre_perro)

# PROGRAMACIÓN ORIENTADA A OBJETOS
class Perro:
    def __init__(self, nombre, edad, raza):
        self.nombre = nombre
        self.edad = edad
        self.raza = raza
    
    def ladrar(self):
        print(f"{self.nombre} dice: ¡Guau!")

# Crear objeto
mi_perro = Perro("Max", 3, "Labrador")
mi_perro.ladrar()  # Max dice: ¡Guau!
`} lang="python" title="POO vs Procedural" />

</TabItem>
</Tabs>

---

## 🏗️ 11.2 Crear clases y objetos en Python

<Tabs>
<TabItem label="👔 Parte Teórica">

### Definir una clase

**Sintaxis**:
<Code code={`class NombreClase:
    # Cuerpo de la clase
    pass`} lang="python" title="Definir una clase" />

### Crear objetos (instancias)

**Sintaxis**:
<Code code={`objeto = NombreClase()`} lang="python" title="Crear objetos (instancias)" />

### Convenciones

**🔹 Nombres de clases**: PascalCase (primera letra de cada palabra en mayúscula)  
**🔹 Nombres de objetos**: snake_case (minúsculas con guiones bajos)  
**🔹 Indentación**: El cuerpo de la clase debe estar indentado  

</TabItem>

<TabItem label="💡 Ejemplos Prácticos">

### Clase básica

<Code code={`# Definir una clase simple
class Persona:
    pass

# Crear objetos (instancias)
persona1 = Persona()
persona2 = Persona()

print(type(persona1))  # <class '__main__.Persona'>
print(persona1 == persona2)  # False (objetos diferentes)`} lang="python" title="Clase básica" />

</TabItem>
</Tabs>

---

## 📊 11.3 Propiedades (atributos) y comportamientos (métodos)

<Tabs>
<TabItem label="👔 Parte Teórica">

### Atributos (propiedades)

Los **atributos** son variables que pertenecen a un objeto y almacenan su estado.

### Métodos (comportamientos)

Los **métodos** son funciones definidas dentro de una clase que describen el comportamiento del objeto. El primer parámetro siempre es self.

</TabItem>

<TabItem label="💡 Ejemplos Prácticos">

### Atributos y métodos

<Code code={`class Perro:
    def __init__(self, nombre, raza):
        self.nombre = nombre  # Atributo
        self.raza = raza      # Atributo
    
    def ladrar(self):  # Método
        print(f"{self.nombre} dice: ¡Guau!")
    
    def presentarse(self):  # Método
        print(f"Hola, soy {self.nombre} y soy un {self.raza}")

mi_perro = Perro("Max", "Labrador")
mi_perro.ladrar()        # Max dice: ¡Guau!
mi_perro.presentarse()   # Hola, soy Max y soy un Labrador`} lang="python" title="Atributos y métodos" />

</TabItem>
</Tabs>

---

## 🎬 11.4 El método __init__() y su función

<Tabs>
<TabItem label="👔 Parte Teórica">

### Concepto de __init__()

El método **`__init__()`** es el constructor de la clase. Se ejecuta automáticamente cuando se crea un nuevo objeto para inicializar sus atributos.

### Sintaxis

<Code code={`def __init__(self, parametros):
    self.atributo = valor`} lang="python" title="__init__()" />

</TabItem>

<TabItem label="💡 Ejemplos Prácticos">

### __init__() básico

<Code code={`class Persona:
    def __init__(self, nombre, edad):
        self.nombre = nombre
        self.edad = edad

persona = Persona("Ana", 25)
print(f"{persona.nombre} tiene {persona.edad} años")`} lang="python" title="__init__()" />

### Con valores por defecto

<Code code={`class CuentaBancaria:
    def __init__(self, titular, saldo=0):
        self.titular = titular
        self.saldo = saldo
    
    def mostrar_saldo(self):
        print(f"Saldo de {self.titular}: {self.saldo} USD")

cuenta1 = CuentaBancaria("Ana", 1000)
cuenta2 = CuentaBancaria("Carlos")  # saldo = 0
cuenta1.mostrar_saldo()  # Saldo de Ana: 1000 USD
`} lang="python" title="Valores por defecto" />

</TabItem>
</Tabs>

---

## 🔒 11.5 Encapsulamiento y uso de self

<Tabs>
<TabItem label="👔 Parte Teórica">

### self

**self** es una referencia al objeto actual. Permite acceder a atributos y métodos del objeto desde dentro de la clase.

### Encapsulamiento

El **encapsulamiento** oculta los detalles internos. En Python:
- **público**: `atributo`
- **protegido**: `_atributo` (convención)
- **privado**: `__atributo` (name mangling)

</TabItem>

<TabItem label="💡 Ejemplos Prácticos">

### Uso de self

<Code code={`class Rectangulo:
    def __init__(self, base, altura):
        self.base = base
        self.altura = altura
    
    def calcular_area(self):
        return self.base * self.altura
    
    def mostrar_info(self):
        area = self.calcular_area()  # Usar self para llamar método
        print(f"Área: {area}")

rect = Rectangulo(5, 3)
rect.mostrar_info()  # Área: 15
`} lang="python" title="self" />

### Encapsulamiento

<Code code={`class CuentaBancaria:
    def __init__(self, titular, saldo_inicial):
        self.titular = titular
        self.__saldo = saldo_inicial  # Privado
    
    def depositar(self, cantidad):
        if cantidad > 0:
            self.__saldo += cantidad
    
    def obtener_saldo(self):
        return self.__saldo

cuenta = CuentaBancaria("Ana", 1000)
cuenta.depositar(500)
print(cuenta.obtener_saldo())  # 1500
`} lang="python" title="Encapsulamiento" />

</TabItem>
</Tabs>

---

## 👨‍👩‍👧 11.6 Herencia y clases hijas

<Tabs>
<TabItem label="👔 Parte Teórica">

### Concepto de herencia

La **herencia** permite crear nuevas clases basadas en clases existentes, heredando sus atributos y métodos.

**Sintaxis**:
<Code code={`class ClaseHija(ClasePadre):
    # Código adicional`} lang="python" title="Herencia" />

### super()

La función **super()** permite acceder a métodos de la clase padre.

</TabItem>

<TabItem label="💡 Ejemplos Prácticos">

### Herencia básica

<Code code={`class Animal:
    def __init__(self, nombre):
        self.nombre = nombre
    
    def hacer_sonido(self):
        print("El animal hace un sonido")

class Perro(Animal):
    def hacer_sonido(self):
        print(f"{self.nombre} dice: ¡Guau!")

class Gato(Animal):
    def hacer_sonido(self):
        print(f"{self.nombre} dice: ¡Miau!")

perro = Perro("Max")
gato = Gato("Luna")
perro.hacer_sonido()  # Max dice: ¡Guau!
gato.hacer_sonido()   # Luna dice: ¡Miau!
`} lang="python" title="Herencia" />

### Usar super()

<Code code={`class Vehiculo:
    def __init__(self, marca, modelo):
        self.marca = marca
        self.modelo = modelo

class Coche(Vehiculo):
    def __init__(self, marca, modelo, puertas):
        super().__init__(marca, modelo)
        self.puertas = puertas

coche = Coche("Toyota", "Corolla", 4)
print(f"{coche.marca} {coche.modelo} - {coche.puertas} puertas")`} lang="python" title="super()" />

</TabItem>
</Tabs>

---

## ⚙️ 11.7 Métodos especiales: __str__(), __len__(), etc.

<Tabs>
<TabItem label="👔 Parte Teórica">

### Métodos mágicos

Los **métodos especiales** permiten personalizar el comportamiento de los objetos.

**`__str__()`**: Representación legible (para print)  
**`__len__()`**: Longitud (para len())  
**`__eq__()`**: Igualdad (para ==)  
**`__add__()`**: Suma (para +)  

</TabItem>

<TabItem label="💡 Ejemplos Prácticos">

### __str__()

<Code code={`class Libro:
    def __init__(self, titulo, autor):
        self.titulo = titulo
        self.autor = autor
    
    def __str__(self):
        return f'"{self.titulo}" por {self.autor}'

libro = Libro("Python 101", "Ana García")
print(libro)  # "Python 101" por Ana García
`} lang="python" title="__str__()" />

### __len__()

<Code code={`class Playlist:
    def __init__(self, nombre):
        self.nombre = nombre
        self.canciones = []
    
    def agregar(self, cancion):
        self.canciones.append(cancion)
    
    def __len__(self):
        return len(self.canciones)

playlist = Playlist("Favoritas")
playlist.agregar("Canción 1")
playlist.agregar("Canción 2")
print(len(playlist))  # 2
`} lang="python" title="__len__()" />

</TabItem>
</Tabs>

---

## 📐 11.8 Buenas prácticas al diseñar clases

<Tabs>
<TabItem label="👔 Parte Teórica">

### Principios de diseño

**🔹 Responsabilidad única**: Una clase debe tener un solo propósito  
**🔹 Encapsulamiento**: Ocultar detalles de implementación  
**🔹 Nombres descriptivos**: Clases y métodos con nombres claros  
**🔹 Documentación**: Usar docstrings  

</TabItem>

<TabItem label="💡 Ejemplos Prácticos">

### Clase bien diseñada

<Code code={`class CuentaBancaria:
    """Representa una cuenta bancaria con operaciones básicas."""
    
    def __init__(self, titular, saldo_inicial=0):
        """Inicializa una nueva cuenta bancaria."""
        self.titular = titular
        self.__saldo = saldo_inicial
    
    def depositar(self, cantidad):
        """Deposita dinero en la cuenta."""
        if cantidad > 0:
            self.__saldo += cantidad
            return True
        return False
    
    def retirar(self, cantidad):
        """Retira dinero de la cuenta."""
        if 0 < cantidad <= self.__saldo:
            self.__saldo -= cantidad
            return True
        return False
    
    def obtener_saldo(self):
        """Retorna el saldo actual."""
        return self.__saldo
    
    def __str__(self):
        return f"Cuenta de {self.titular}: {self.__saldo:.2f} USD"

cuenta = CuentaBancaria("Ana García", 1000)
cuenta.depositar(500)
print(cuenta)  # Cuenta de Ana García: 1500.00 USD`} lang="python" title="Clase bien diseñada" />

<Aside type="tip" title="💡 Reglas de oro">
1. **Una clase, un propósito**: No mezclar responsabilidades
2. **Encapsular datos**: Usar atributos privados con métodos de acceso
3. **Documentar todo**: Docstrings claros y concisos
4. **Nombres descriptivos**: Que expliquen qué hace la clase/método
5. **Métodos pequeños**: Funciones cortas y específicas
6. **Herencia con moderación**: Solo cuando hay relación "es-un"
7. **Implementar __str__()**: Para representación legible
8. **Validar en __init__()**: Asegurar estado válido desde el inicio
</Aside>

</TabItem>
</Tabs>

---

## 🎯 Resumen de la lección

<Aside type="tip" title="📚 Lo que aprendiste">
En esta lección sobre Programación Orientada a Objetos has aprendido:

✅ **POO**: Paradigma que organiza código en objetos con atributos y métodos  
✅ **Clases y objetos**: Plantillas y sus instancias específicas  
✅ **Atributos y métodos**: Propiedades y comportamientos de objetos  
✅ **__init__()**: Constructor para inicializar objetos  
✅ **Encapsulamiento y self**: Ocultar detalles, usar self para referenciar el objeto  
✅ **Herencia**: Crear clases hijas que heredan de clases padres  
✅ **Métodos especiales**: __str__(), __len__(), __eq__() para personalizar comportamiento  
✅ **Buenas prácticas**: Responsabilidad única, encapsulamiento, documentación  

**Próximo paso**: Ahora tienes las bases de POO para crear aplicaciones más complejas y organizadas.
</Aside>
