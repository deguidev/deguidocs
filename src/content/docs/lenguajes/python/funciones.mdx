---
title: 8. Funciones en Python
description: DefiniciÃ³n de funciones con def, parÃ¡metros, argumentos y valores de retorno
---

import { Code } from '@astrojs/starlight/components';
import { Tabs, TabItem } from '@astrojs/starlight/components';
import { Badge } from '@astrojs/starlight/components';
import { Aside } from '@astrojs/starlight/components';
import { Steps } from '@astrojs/starlight/components';

## ğŸ¯ 8.1 Â¿QuÃ© es una funciÃ³n y para quÃ© sirve?

<Tabs>
<TabItem label="ğŸ‘” Parte TeÃ³rica">

### Concepto de funciÃ³n

Una **funciÃ³n** es un bloque de cÃ³digo reutilizable que realiza una tarea especÃ­fica. Es una de las herramientas fundamentales para organizar y estructurar programas de manera eficiente.

### PropÃ³sito de las funciones

**ğŸ”¹ ReutilizaciÃ³n de cÃ³digo**: Evita duplicar cÃ³digo escribiendo una vez y usando mÃºltiples veces  
**ğŸ”¹ Modularidad**: Divide programas complejos en partes mÃ¡s pequeÃ±as y manejables  
**ğŸ”¹ AbstracciÃ³n**: Oculta detalles de implementaciÃ³n, mostrando solo la interfaz  
**ğŸ”¹ Mantenibilidad**: Facilita actualizar y corregir cÃ³digo en un solo lugar  
**ğŸ”¹ Legibilidad**: Hace el cÃ³digo mÃ¡s claro y fÃ¡cil de entender  

### Componentes de una funciÃ³n

**DefiniciÃ³n**: DeclaraciÃ³n de la funciÃ³n con `def`  
**Nombre**: Identificador Ãºnico para llamar la funciÃ³n  
**ParÃ¡metros**: Variables que recibe la funciÃ³n (opcional)  
**Cuerpo**: Bloque de cÃ³digo que ejecuta la funciÃ³n  
**Retorno**: Valor que devuelve la funciÃ³n (opcional)  

### AnalogÃ­a

Una funciÃ³n es como una receta de cocina: defines los pasos una vez (ingredientes = parÃ¡metros, procedimiento = cuerpo) y puedes usarla cada vez que necesites preparar ese platillo (llamada a la funciÃ³n).

</TabItem>

<TabItem label="ğŸ’¡ Ejemplos PrÃ¡cticos">

### Sin funciones vs con funciones

<Code code={`# SIN FUNCIONES (cÃ³digo repetitivo)
print("Hola, Ana")
print("Bienvenida al sistema")
print("---")

print("Hola, Juan")
print("Bienvenido al sistema")
print("---")

print("Hola, MarÃ­a")
print("Bienvenida al sistema")
print("---")

# CON FUNCIONES (cÃ³digo reutilizable)
def saludar(nombre):
    print(f"Hola, {nombre}")
    print("Bienvenido al sistema")
    print("---")

saludar("Ana")
saludar("Juan")
saludar("MarÃ­a")`} lang="python" title="ComparaciÃ³n" />

### Ventajas de usar funciones

<Code code={`# Calcular Ã¡rea de rectÃ¡ngulo sin funciÃ³n
base1 = 5
altura1 = 3
area1 = base1 * altura1
print(f"Ãrea 1: {area1}")

base2 = 8
altura2 = 4
area2 = base2 * altura2
print(f"Ãrea 2: {area2}")

# Con funciÃ³n (mÃ¡s limpio y reutilizable)
def calcular_area_rectangulo(base, altura):
    return base * altura

area1 = calcular_area_rectangulo(5, 3)
area2 = calcular_area_rectangulo(8, 4)
print(f"Ãrea 1: {area1}")
print(f"Ãrea 2: {area2}")`} lang="python" title="Ventajas" />

</TabItem>
</Tabs>

---

## ğŸ“ 8.2 CÃ³mo definir funciones con def

<Tabs>
<TabItem label="ğŸ‘” Parte TeÃ³rica">

### Sintaxis de definiciÃ³n

```python
def nombre_funcion(parametros):
    """Docstring: descripciÃ³n de la funciÃ³n"""
    # Cuerpo de la funciÃ³n
    return valor  # Opcional
```

### Elementos de la definiciÃ³n

**def**: Palabra clave para definir una funciÃ³n  
**nombre_funcion**: Identificador de la funciÃ³n (debe seguir reglas de nombres)  
**parametros**: Variables que recibe (entre parÃ©ntesis, separados por comas)  
**docstring**: DocumentaciÃ³n opcional de la funciÃ³n (entre triple comillas)  
**return**: Devuelve un valor (opcional, si no hay return, devuelve None)  

### Reglas importantes

**ğŸ”¹ IndentaciÃ³n**: El cuerpo de la funciÃ³n debe estar indentado (4 espacios)  
**ğŸ”¹ DefiniciÃ³n antes de uso**: La funciÃ³n debe definirse antes de llamarla  
**ğŸ”¹ Nombres descriptivos**: Usar nombres que indiquen quÃ© hace la funciÃ³n  
**ğŸ”¹ ConvenciÃ³n**: Usar snake_case para nombres de funciones  

</TabItem>

<TabItem label="ğŸ’¡ Ejemplos PrÃ¡cticos">

### FunciÃ³n simple sin parÃ¡metros

<Code code={`# FunciÃ³n que no recibe parÃ¡metros ni retorna valor
def saludar():
    print("Â¡Hola, mundo!")

# Llamar la funciÃ³n
saludar()  # Salida: Â¡Hola, mundo!
saludar()  # Salida: Â¡Hola, mundo!`} lang="python" title="FunciÃ³n simple" />

### FunciÃ³n con parÃ¡metros

<Code code={`# FunciÃ³n que recibe parÃ¡metros
def saludar_persona(nombre):
    print(f"Hola, {nombre}!")

# Llamar con diferentes argumentos
saludar_persona("Ana")    # Hola, Ana!
saludar_persona("Carlos") # Hola, Carlos!`} lang="python" title="Con parÃ¡metros" />

### FunciÃ³n con return

<Code code={`# FunciÃ³n que retorna un valor
def sumar(a, b):
    resultado = a + b
    return resultado

# Usar el valor retornado
total = sumar(5, 3)
print(total)  # 8

# Usar directamente en expresiones
print(sumar(10, 20))  # 30`} lang="python" title="Con return" />

### FunciÃ³n con docstring

<Code code={`def calcular_area_circulo(radio):
    """
    Calcula el Ã¡rea de un cÃ­rculo.
    
    Args:
        radio (float): Radio del cÃ­rculo
        
    Returns:
        float: Ãrea del cÃ­rculo
    """
    pi = 3.14159
    area = pi * radio ** 2
    return area

# Usar la funciÃ³n
area = calcular_area_circulo(5)
print(f"Ãrea: {area:.2f}")

# Ver documentaciÃ³n
print(calcular_area_circulo.__doc__)`} lang="python" title="Con docstring" />

</TabItem>
</Tabs>

---

## ğŸ”„ 8.3 ParÃ¡metros, argumentos y valores de retorno

<Tabs>
<TabItem label="ğŸ‘” Parte TeÃ³rica">

### Diferencia entre parÃ¡metros y argumentos

**ParÃ¡metros**: Variables definidas en la declaraciÃ³n de la funciÃ³n  
**Argumentos**: Valores reales pasados al llamar la funciÃ³n  

### Tipos de argumentos

**Posicionales**: Se pasan en el orden definido  
**Por nombre (keyword)**: Se especifica el nombre del parÃ¡metro  
**Mixtos**: CombinaciÃ³n de posicionales y por nombre  

### Valores de retorno

**return simple**: Devuelve un solo valor  
**return mÃºltiple**: Devuelve varios valores (tupla)  
**sin return**: La funciÃ³n retorna `None` implÃ­citamente  

### CaracterÃ­sticas importantes

**ğŸ”¹ Paso por referencia**: Los objetos mutables se pasan por referencia  
**ğŸ”¹ MÃºltiples returns**: Una funciÃ³n puede tener varios return (solo se ejecuta uno)  
**ğŸ”¹ Return termina ejecuciÃ³n**: El cÃ³digo despuÃ©s de return no se ejecuta  

</TabItem>

<TabItem label="ğŸ’¡ Ejemplos PrÃ¡cticos">

### ParÃ¡metros y argumentos posicionales

<Code code={`# FunciÃ³n con mÃºltiples parÃ¡metros
def presentar(nombre, edad, ciudad):
    print(f"Me llamo {nombre}")
    print(f"Tengo {edad} aÃ±os")
    print(f"Vivo en {ciudad}")

# Argumentos posicionales (orden importa)
presentar("Ana", 25, "Madrid")

# Salida:
# Me llamo Ana
# Tengo 25 aÃ±os
# Vivo en Madrid`} lang="python" title="Argumentos posicionales" />

### Argumentos por nombre (keyword)

<Code code={`def presentar(nombre, edad, ciudad):
    print(f"{nombre}, {edad} aÃ±os, {ciudad}")

# Argumentos por nombre (orden no importa)
presentar(edad=30, ciudad="Barcelona", nombre="Carlos")

# Mezclar posicionales y por nombre
presentar("MarÃ­a", ciudad="Valencia", edad=28)`} lang="python" title="Argumentos por nombre" />

### Return simple

<Code code={`# FunciÃ³n que retorna un valor
def cuadrado(numero):
    return numero ** 2

resultado = cuadrado(5)
print(resultado)  # 25

# Usar en expresiones
print(cuadrado(3) + cuadrado(4))  # 9 + 16 = 25`} lang="python" title="Return simple" />

### Return mÃºltiple

<Code code={`# FunciÃ³n que retorna mÃºltiples valores
def operaciones(a, b):
    suma = a + b
    resta = a - b
    multiplicacion = a * b
    return suma, resta, multiplicacion

# Recibir mÃºltiples valores
s, r, m = operaciones(10, 5)
print(f"Suma: {s}")           # 15
print(f"Resta: {r}")          # 5
print(f"MultiplicaciÃ³n: {m}") # 50

# O recibir como tupla
resultados = operaciones(8, 3)
print(resultados)  # (11, 5, 24)`} lang="python" title="Return mÃºltiple" />

### FunciÃ³n sin return

<Code code={`# FunciÃ³n sin return (retorna None)
def imprimir_tabla(numero):
    for i in range(1, 6):
        print(f"{numero} x {i} = {numero * i}")

resultado = imprimir_tabla(5)
print(f"Retorno: {resultado}")  # None`} lang="python" title="Sin return" />

### Return temprano

<Code code={`# Usar return para salir temprano
def dividir(a, b):
    if b == 0:
        print("Error: DivisiÃ³n por cero")
        return None
    
    return a / b

print(dividir(10, 2))  # 5.0
print(dividir(10, 0))  # Error: DivisiÃ³n por cero, None`} lang="python" title="Return temprano" />

</TabItem>
</Tabs>

---

## âš™ï¸ 8.4 Funciones con valores por defecto

<Tabs>
<TabItem label="ğŸ‘” Parte TeÃ³rica">

### Concepto de valores por defecto

Los **valores por defecto** (o parÃ¡metros opcionales) permiten definir valores predeterminados para parÃ¡metros. Si no se proporciona un argumento al llamar la funciÃ³n, se usa el valor por defecto.

### Sintaxis

```python
def funcion(parametro1, parametro2=valor_defecto):
    # cÃ³digo
```

### Reglas importantes

**ğŸ”¹ Orden**: ParÃ¡metros con valores por defecto deben ir despuÃ©s de los obligatorios  
**ğŸ”¹ Flexibilidad**: Permite llamar la funciÃ³n con menos argumentos  
**ğŸ”¹ Sobrescritura**: Se puede proporcionar un valor diferente al llamar  
**ğŸ”¹ Valores mutables**: Evitar usar listas o diccionarios como valores por defecto  

### Ventajas

- Mayor flexibilidad al llamar funciones
- Reduce la necesidad de mÃºltiples versiones de la misma funciÃ³n
- Hace el cÃ³digo mÃ¡s limpio y fÃ¡cil de usar

</TabItem>

<TabItem label="ğŸ’¡ Ejemplos PrÃ¡cticos">

### Valores por defecto bÃ¡sicos

<Code code={`# FunciÃ³n con valor por defecto
def saludar(nombre, saludo="Hola"):
    print(f"{saludo}, {nombre}!")

# Usar valor por defecto
saludar("Ana")  # Hola, Ana!

# Proporcionar valor personalizado
saludar("Carlos", "Buenos dÃ­as")  # Buenos dÃ­as, Carlos!
saludar("MarÃ­a", saludo="Buenas tardes")  # Buenas tardes, MarÃ­a!`} lang="python" title="Valores por defecto" />

### MÃºltiples valores por defecto

<Code code={`def crear_perfil(nombre, edad=18, ciudad="Madrid", activo=True):
    print(f"Nombre: {nombre}")
    print(f"Edad: {edad}")
    print(f"Ciudad: {ciudad}")
    print(f"Activo: {activo}")

# Usar todos los valores por defecto
crear_perfil("Ana")

# Sobrescribir algunos valores
crear_perfil("Carlos", edad=25)

# Usar argumentos por nombre
crear_perfil("MarÃ­a", ciudad="Barcelona", edad=30)`} lang="python" title="MÃºltiples valores" />

### FunciÃ³n de potencia con exponente por defecto

<Code code={`def potencia(base, exponente=2):
    """Calcula la potencia de un nÃºmero."""
    return base ** exponente

# Usar valor por defecto (cuadrado)
print(potencia(5))      # 25 (5^2)
print(potencia(3))      # 9 (3^2)

# Especificar exponente
print(potencia(2, 3))   # 8 (2^3)
print(potencia(5, 3))   # 125 (5^3)`} lang="python" title="Potencia" />

### FunciÃ³n de formato con opciones

<Code code={`def formatear_precio(precio, moneda="EUR", decimales=2):
    """Formatea un precio con moneda."""
    return f"{precio:.{decimales}f} {moneda}"

# Usar valores por defecto
print(formatear_precio(19.99))  # 19.99 EUR

# Cambiar moneda
print(formatear_precio(25.5, "USD"))  # 25.50 USD

# Cambiar decimales
print(formatear_precio(100, decimales=0))  # 100 EUR

# Cambiar todo
print(formatear_precio(49.999, "MXN", 1))  # 50.0 MXN`} lang="python" title="Formato de precio" />

<Aside type="caution" title="âš ï¸ Cuidado con valores mutables">
Evita usar listas o diccionarios como valores por defecto, ya que se comparten entre llamadas:

```python
# âŒ INCORRECTO
def agregar_item(item, lista=[]):
    lista.append(item)
    return lista

print(agregar_item(1))  # [1]
print(agregar_item(2))  # [1, 2] Â¡Inesperado!

# âœ… CORRECTO
def agregar_item(item, lista=None):
    if lista is None:
        lista = []
    lista.append(item)
    return lista

print(agregar_item(1))  # [1]
print(agregar_item(2))  # [2] âœ“
```
</Aside>

</TabItem>
</Tabs>

---

## ğŸ“ 8.5 Buenas prÃ¡cticas al nombrar funciones

<Tabs>
<TabItem label="ğŸ‘” Parte TeÃ³rica">

### Convenciones de nomenclatura

**ğŸ”¹ snake_case**: Usar minÃºsculas con guiones bajos (`calcular_promedio`)  
**ğŸ”¹ Verbos descriptivos**: Comenzar con verbos que indiquen la acciÃ³n (`obtener_`, `calcular_`, `validar_`)  
**ğŸ”¹ Nombres claros**: Ser especÃ­fico sobre quÃ© hace la funciÃ³n  
**ğŸ”¹ Evitar abreviaturas**: Preferir nombres completos y legibles  

### Patrones comunes

**get_**: Obtener un valor (`get_nombre`, `get_edad`)  
**set_**: Establecer un valor (`set_precio`, `set_estado`)  
**is_/has_**: Verificar condiciÃ³n, retorna booleano (`is_valid`, `has_permission`)  
**calculate_**: Realizar cÃ¡lculos (`calculate_total`, `calculate_average`)  
**validate_**: Validar datos (`validate_email`, `validate_age`)  
**format_**: Formatear datos (`format_date`, `format_currency`)  

### Principios

**Ãšnica responsabilidad**: Una funciÃ³n debe hacer una sola cosa  
**Nombres autodocumentados**: El nombre debe explicar quÃ© hace  
**Consistencia**: Usar el mismo estilo en todo el cÃ³digo  
**Longitud apropiada**: Ni muy corto ni muy largo (2-4 palabras ideal)  

</TabItem>

<TabItem label="ğŸ’¡ Ejemplos PrÃ¡cticos">

### Buenos vs malos nombres

<Code code={`# âŒ MALOS NOMBRES
def f(x):  # No descriptivo
    return x * 2

def calc(a, b):  # Abreviatura confusa
    return a + b

def datos():  # Muy genÃ©rico
    return [1, 2, 3]

# âœ… BUENOS NOMBRES
def duplicar_numero(numero):
    return numero * 2

def calcular_suma(primer_numero, segundo_numero):
    return primer_numero + segundo_numero

def obtener_numeros_primos():
    return [2, 3, 5, 7, 11]`} lang="python" title="Buenos vs malos" />

### Nombres con verbos descriptivos

<Code code={`# Funciones con verbos claros
def obtener_edad_usuario():
    return 25

def calcular_area_rectangulo(base, altura):
    return base * altura

def validar_email(email):
    return "@" in email

def formatear_fecha(dia, mes, anio):
    return f"{dia:02d}/{mes:02d}/{anio}"

def es_numero_par(numero):
    return numero % 2 == 0

def tiene_mayusculas(texto):
    return any(c.isupper() for c in texto)`} lang="python" title="Verbos descriptivos" />

### Funciones con nombres autodocumentados

<Code code={`# El nombre explica claramente quÃ© hace
def convertir_celsius_a_fahrenheit(celsius):
    return (celsius * 9/5) + 32

def calcular_precio_con_descuento(precio, descuento):
    return precio * (1 - descuento / 100)

def obtener_primer_elemento_lista(lista):
    return lista[0] if lista else None

def verificar_si_es_mayor_de_edad(edad):
    return edad >= 18

# Uso claro sin necesidad de documentaciÃ³n adicional
temperatura_f = convertir_celsius_a_fahrenheit(25)
precio_final = calcular_precio_con_descuento(100, 20)
primer_item = obtener_primer_elemento_lista([1, 2, 3])
es_mayor = verificar_si_es_mayor_de_edad(20)`} lang="python" title="Autodocumentados" />

### Consistencia en el cÃ³digo

<Code code={`# MÃ³dulo de gestiÃ³n de usuarios - Nombres consistentes

def obtener_usuario_por_id(user_id):
    """Obtiene un usuario por su ID."""
    pass

def obtener_usuario_por_email(email):
    """Obtiene un usuario por su email."""
    pass

def crear_usuario(nombre, email):
    """Crea un nuevo usuario."""
    pass

def actualizar_usuario(user_id, datos):
    """Actualiza los datos de un usuario."""
    pass

def eliminar_usuario(user_id):
    """Elimina un usuario."""
    pass

def validar_datos_usuario(datos):
    """Valida los datos de un usuario."""
    pass

# PatrÃ³n consistente: verbo + sustantivo + complemento`} lang="python" title="Consistencia" />

### Funciones booleanas

<Code code={`# Funciones que retornan booleano: usar is_, has_, can_

def es_numero_primo(numero):
    """Verifica si un nÃºmero es primo."""
    if numero < 2:
        return False
    for i in range(2, numero):
        if numero % i == 0:
            return False
    return True

def tiene_caracteres_especiales(texto):
    """Verifica si el texto tiene caracteres especiales."""
    especiales = "!@#$%^&*()_+-=[]{}|;:,.<>?"
    return any(c in especiales for c in texto)

def puede_votar(edad):
    """Verifica si una persona puede votar."""
    return edad >= 18

def esta_vacio(lista):
    """Verifica si una lista estÃ¡ vacÃ­a."""
    return len(lista) == 0

# Uso intuitivo en condicionales
if es_numero_primo(7):
    print("Es primo")

if tiene_caracteres_especiales("abc!"):
    print("Tiene caracteres especiales")`} lang="python" title="Funciones booleanas" />

<Aside type="tip" title="ğŸ’¡ Reglas de oro">
1. **Claridad sobre brevedad**: Mejor `calcular_promedio_notas` que `calc_prom`
2. **Verbos para acciones**: `obtener`, `calcular`, `validar`, `crear`, `actualizar`
3. **Prefijos booleanos**: `es_`, `tiene_`, `puede_` para funciones que retornan bool
4. **Consistencia**: MantÃ©n el mismo estilo en todo el proyecto
5. **Evita redundancia**: No uses `funcion_` al inicio (ya es obvio que es una funciÃ³n)
</Aside>

</TabItem>
</Tabs>

---

## ğŸ¯ Resumen de la lecciÃ³n

<Aside type="tip" title="ğŸ“š Lo que aprendiste">
En esta lecciÃ³n sobre funciones en Python has aprendido:

âœ… **Concepto de funciÃ³n**: Bloques reutilizables de cÃ³digo para modularidad y mantenibilidad  
âœ… **DefiniciÃ³n con def**: Sintaxis, parÃ¡metros, cuerpo, docstring y return  
âœ… **ParÃ¡metros y argumentos**: Posicionales, por nombre, valores de retorno simples y mÃºltiples  
âœ… **Valores por defecto**: ParÃ¡metros opcionales para mayor flexibilidad  
âœ… **Buenas prÃ¡cticas**: Nomenclatura clara, verbos descriptivos, nombres autodocumentados  

**PrÃ³ximo paso**: En la siguiente lecciÃ³n aprenderÃ¡s sobre mÃ³dulos y paquetes en Python.
</Aside>
