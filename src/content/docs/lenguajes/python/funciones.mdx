---
title: 8. Funciones en Python
description: Definición de funciones con def, parámetros, argumentos y valores de retorno
---

import { Code } from '@astrojs/starlight/components';
import { Tabs, TabItem } from '@astrojs/starlight/components';
import { Badge } from '@astrojs/starlight/components';
import { Aside } from '@astrojs/starlight/components';
import { Steps } from '@astrojs/starlight/components';

## 🎯 8.1 ¿Qué es una función y para qué sirve?

<Tabs>
<TabItem label="👔 Parte Teórica">

### Concepto de función

Una **función** es un bloque de código reutilizable que realiza una tarea específica. Es una de las herramientas fundamentales para organizar y estructurar programas de manera eficiente.

### Propósito de las funciones

**🔹 Reutilización de código**: Evita duplicar código escribiendo una vez y usando múltiples veces  
**🔹 Modularidad**: Divide programas complejos en partes más pequeñas y manejables  
**🔹 Abstracción**: Oculta detalles de implementación, mostrando solo la interfaz  
**🔹 Mantenibilidad**: Facilita actualizar y corregir código en un solo lugar  
**🔹 Legibilidad**: Hace el código más claro y fácil de entender  

### Componentes de una función

**Definición**: Declaración de la función con `def`  
**Nombre**: Identificador único para llamar la función  
**Parámetros**: Variables que recibe la función (opcional)  
**Cuerpo**: Bloque de código que ejecuta la función  
**Retorno**: Valor que devuelve la función (opcional)  

### Analogía

Una función es como una receta de cocina: defines los pasos una vez (ingredientes = parámetros, procedimiento = cuerpo) y puedes usarla cada vez que necesites preparar ese platillo (llamada a la función).

</TabItem>

<TabItem label="💡 Ejemplos Prácticos">

### Sin funciones vs con funciones

<Code code={`# SIN FUNCIONES (código repetitivo)
print("Hola, Ana")
print("Bienvenida al sistema")
print("---")

print("Hola, Juan")
print("Bienvenido al sistema")
print("---")

print("Hola, María")
print("Bienvenida al sistema")
print("---")

# CON FUNCIONES (código reutilizable)
def saludar(nombre):
    print(f"Hola, {nombre}")
    print("Bienvenido al sistema")
    print("---")

saludar("Ana")
saludar("Juan")
saludar("María")`} lang="python" title="Comparación" />

### Ventajas de usar funciones

<Code code={`# Calcular área de rectángulo sin función
base1 = 5
altura1 = 3
area1 = base1 * altura1
print(f"Área 1: {area1}")

base2 = 8
altura2 = 4
area2 = base2 * altura2
print(f"Área 2: {area2}")

# Con función (más limpio y reutilizable)
def calcular_area_rectangulo(base, altura):
    return base * altura

area1 = calcular_area_rectangulo(5, 3)
area2 = calcular_area_rectangulo(8, 4)
print(f"Área 1: {area1}")
print(f"Área 2: {area2}")`} lang="python" title="Ventajas" />

</TabItem>
</Tabs>

---

## 📝 8.2 Cómo definir funciones con def

<Tabs>
<TabItem label="👔 Parte Teórica">

### Sintaxis de definición

```python
def nombre_funcion(parametros):
    """Docstring: descripción de la función"""
    # Cuerpo de la función
    return valor  # Opcional
```

### Elementos de la definición

**def**: Palabra clave para definir una función  
**nombre_funcion**: Identificador de la función (debe seguir reglas de nombres)  
**parametros**: Variables que recibe (entre paréntesis, separados por comas)  
**docstring**: Documentación opcional de la función (entre triple comillas)  
**return**: Devuelve un valor (opcional, si no hay return, devuelve None)  

### Reglas importantes

**🔹 Indentación**: El cuerpo de la función debe estar indentado (4 espacios)  
**🔹 Definición antes de uso**: La función debe definirse antes de llamarla  
**🔹 Nombres descriptivos**: Usar nombres que indiquen qué hace la función  
**🔹 Convención**: Usar snake_case para nombres de funciones  

</TabItem>

<TabItem label="💡 Ejemplos Prácticos">

### Función simple sin parámetros

<Code code={`# Función que no recibe parámetros ni retorna valor
def saludar():
    print("¡Hola, mundo!")

# Llamar la función
saludar()  # Salida: ¡Hola, mundo!
saludar()  # Salida: ¡Hola, mundo!`} lang="python" title="Función simple" />

### Función con parámetros

<Code code={`# Función que recibe parámetros
def saludar_persona(nombre):
    print(f"Hola, {nombre}!")

# Llamar con diferentes argumentos
saludar_persona("Ana")    # Hola, Ana!
saludar_persona("Carlos") # Hola, Carlos!`} lang="python" title="Con parámetros" />

### Función con return

<Code code={`# Función que retorna un valor
def sumar(a, b):
    resultado = a + b
    return resultado

# Usar el valor retornado
total = sumar(5, 3)
print(total)  # 8

# Usar directamente en expresiones
print(sumar(10, 20))  # 30`} lang="python" title="Con return" />

### Función con docstring

<Code code={`def calcular_area_circulo(radio):
    """
    Calcula el área de un círculo.
    
    Args:
        radio (float): Radio del círculo
        
    Returns:
        float: Área del círculo
    """
    pi = 3.14159
    area = pi * radio ** 2
    return area

# Usar la función
area = calcular_area_circulo(5)
print(f"Área: {area:.2f}")

# Ver documentación
print(calcular_area_circulo.__doc__)`} lang="python" title="Con docstring" />

</TabItem>
</Tabs>

---

## 🔄 8.3 Parámetros, argumentos y valores de retorno

<Tabs>
<TabItem label="👔 Parte Teórica">

### Diferencia entre parámetros y argumentos

**Parámetros**: Variables definidas en la declaración de la función  
**Argumentos**: Valores reales pasados al llamar la función  

### Tipos de argumentos

**Posicionales**: Se pasan en el orden definido  
**Por nombre (keyword)**: Se especifica el nombre del parámetro  
**Mixtos**: Combinación de posicionales y por nombre  

### Valores de retorno

**return simple**: Devuelve un solo valor  
**return múltiple**: Devuelve varios valores (tupla)  
**sin return**: La función retorna `None` implícitamente  

### Características importantes

**🔹 Paso por referencia**: Los objetos mutables se pasan por referencia  
**🔹 Múltiples returns**: Una función puede tener varios return (solo se ejecuta uno)  
**🔹 Return termina ejecución**: El código después de return no se ejecuta  

</TabItem>

<TabItem label="💡 Ejemplos Prácticos">

### Parámetros y argumentos posicionales

<Code code={`# Función con múltiples parámetros
def presentar(nombre, edad, ciudad):
    print(f"Me llamo {nombre}")
    print(f"Tengo {edad} años")
    print(f"Vivo en {ciudad}")

# Argumentos posicionales (orden importa)
presentar("Ana", 25, "Madrid")

# Salida:
# Me llamo Ana
# Tengo 25 años
# Vivo en Madrid`} lang="python" title="Argumentos posicionales" />

### Argumentos por nombre (keyword)

<Code code={`def presentar(nombre, edad, ciudad):
    print(f"{nombre}, {edad} años, {ciudad}")

# Argumentos por nombre (orden no importa)
presentar(edad=30, ciudad="Barcelona", nombre="Carlos")

# Mezclar posicionales y por nombre
presentar("María", ciudad="Valencia", edad=28)`} lang="python" title="Argumentos por nombre" />

### Return simple

<Code code={`# Función que retorna un valor
def cuadrado(numero):
    return numero ** 2

resultado = cuadrado(5)
print(resultado)  # 25

# Usar en expresiones
print(cuadrado(3) + cuadrado(4))  # 9 + 16 = 25`} lang="python" title="Return simple" />

### Return múltiple

<Code code={`# Función que retorna múltiples valores
def operaciones(a, b):
    suma = a + b
    resta = a - b
    multiplicacion = a * b
    return suma, resta, multiplicacion

# Recibir múltiples valores
s, r, m = operaciones(10, 5)
print(f"Suma: {s}")           # 15
print(f"Resta: {r}")          # 5
print(f"Multiplicación: {m}") # 50

# O recibir como tupla
resultados = operaciones(8, 3)
print(resultados)  # (11, 5, 24)`} lang="python" title="Return múltiple" />

### Función sin return

<Code code={`# Función sin return (retorna None)
def imprimir_tabla(numero):
    for i in range(1, 6):
        print(f"{numero} x {i} = {numero * i}")

resultado = imprimir_tabla(5)
print(f"Retorno: {resultado}")  # None`} lang="python" title="Sin return" />

### Return temprano

<Code code={`# Usar return para salir temprano
def dividir(a, b):
    if b == 0:
        print("Error: División por cero")
        return None
    
    return a / b

print(dividir(10, 2))  # 5.0
print(dividir(10, 0))  # Error: División por cero, None`} lang="python" title="Return temprano" />

</TabItem>
</Tabs>

---

## ⚙️ 8.4 Funciones con valores por defecto

<Tabs>
<TabItem label="👔 Parte Teórica">

### Concepto de valores por defecto

Los **valores por defecto** (o parámetros opcionales) permiten definir valores predeterminados para parámetros. Si no se proporciona un argumento al llamar la función, se usa el valor por defecto.

### Sintaxis

```python
def funcion(parametro1, parametro2=valor_defecto):
    # código
```

### Reglas importantes

**🔹 Orden**: Parámetros con valores por defecto deben ir después de los obligatorios  
**🔹 Flexibilidad**: Permite llamar la función con menos argumentos  
**🔹 Sobrescritura**: Se puede proporcionar un valor diferente al llamar  
**🔹 Valores mutables**: Evitar usar listas o diccionarios como valores por defecto  

### Ventajas

- Mayor flexibilidad al llamar funciones
- Reduce la necesidad de múltiples versiones de la misma función
- Hace el código más limpio y fácil de usar

</TabItem>

<TabItem label="💡 Ejemplos Prácticos">

### Valores por defecto básicos

<Code code={`# Función con valor por defecto
def saludar(nombre, saludo="Hola"):
    print(f"{saludo}, {nombre}!")

# Usar valor por defecto
saludar("Ana")  # Hola, Ana!

# Proporcionar valor personalizado
saludar("Carlos", "Buenos días")  # Buenos días, Carlos!
saludar("María", saludo="Buenas tardes")  # Buenas tardes, María!`} lang="python" title="Valores por defecto" />

### Múltiples valores por defecto

<Code code={`def crear_perfil(nombre, edad=18, ciudad="Madrid", activo=True):
    print(f"Nombre: {nombre}")
    print(f"Edad: {edad}")
    print(f"Ciudad: {ciudad}")
    print(f"Activo: {activo}")

# Usar todos los valores por defecto
crear_perfil("Ana")

# Sobrescribir algunos valores
crear_perfil("Carlos", edad=25)

# Usar argumentos por nombre
crear_perfil("María", ciudad="Barcelona", edad=30)`} lang="python" title="Múltiples valores" />

### Función de potencia con exponente por defecto

<Code code={`def potencia(base, exponente=2):
    """Calcula la potencia de un número."""
    return base ** exponente

# Usar valor por defecto (cuadrado)
print(potencia(5))      # 25 (5^2)
print(potencia(3))      # 9 (3^2)

# Especificar exponente
print(potencia(2, 3))   # 8 (2^3)
print(potencia(5, 3))   # 125 (5^3)`} lang="python" title="Potencia" />

### Función de formato con opciones

<Code code={`def formatear_precio(precio, moneda="EUR", decimales=2):
    """Formatea un precio con moneda."""
    return f"{precio:.{decimales}f} {moneda}"

# Usar valores por defecto
print(formatear_precio(19.99))  # 19.99 EUR

# Cambiar moneda
print(formatear_precio(25.5, "USD"))  # 25.50 USD

# Cambiar decimales
print(formatear_precio(100, decimales=0))  # 100 EUR

# Cambiar todo
print(formatear_precio(49.999, "MXN", 1))  # 50.0 MXN`} lang="python" title="Formato de precio" />

<Aside type="caution" title="⚠️ Cuidado con valores mutables">
Evita usar listas o diccionarios como valores por defecto, ya que se comparten entre llamadas:

```python
# ❌ INCORRECTO
def agregar_item(item, lista=[]):
    lista.append(item)
    return lista

print(agregar_item(1))  # [1]
print(agregar_item(2))  # [1, 2] ¡Inesperado!

# ✅ CORRECTO
def agregar_item(item, lista=None):
    if lista is None:
        lista = []
    lista.append(item)
    return lista

print(agregar_item(1))  # [1]
print(agregar_item(2))  # [2] ✓
```
</Aside>

</TabItem>
</Tabs>

---

## 📐 8.5 Buenas prácticas al nombrar funciones

<Tabs>
<TabItem label="👔 Parte Teórica">

### Convenciones de nomenclatura

**🔹 snake_case**: Usar minúsculas con guiones bajos (`calcular_promedio`)  
**🔹 Verbos descriptivos**: Comenzar con verbos que indiquen la acción (`obtener_`, `calcular_`, `validar_`)  
**🔹 Nombres claros**: Ser específico sobre qué hace la función  
**🔹 Evitar abreviaturas**: Preferir nombres completos y legibles  

### Patrones comunes

**get_**: Obtener un valor (`get_nombre`, `get_edad`)  
**set_**: Establecer un valor (`set_precio`, `set_estado`)  
**is_/has_**: Verificar condición, retorna booleano (`is_valid`, `has_permission`)  
**calculate_**: Realizar cálculos (`calculate_total`, `calculate_average`)  
**validate_**: Validar datos (`validate_email`, `validate_age`)  
**format_**: Formatear datos (`format_date`, `format_currency`)  

### Principios

**Única responsabilidad**: Una función debe hacer una sola cosa  
**Nombres autodocumentados**: El nombre debe explicar qué hace  
**Consistencia**: Usar el mismo estilo en todo el código  
**Longitud apropiada**: Ni muy corto ni muy largo (2-4 palabras ideal)  

</TabItem>

<TabItem label="💡 Ejemplos Prácticos">

### Buenos vs malos nombres

<Code code={`# ❌ MALOS NOMBRES
def f(x):  # No descriptivo
    return x * 2

def calc(a, b):  # Abreviatura confusa
    return a + b

def datos():  # Muy genérico
    return [1, 2, 3]

# ✅ BUENOS NOMBRES
def duplicar_numero(numero):
    return numero * 2

def calcular_suma(primer_numero, segundo_numero):
    return primer_numero + segundo_numero

def obtener_numeros_primos():
    return [2, 3, 5, 7, 11]`} lang="python" title="Buenos vs malos" />

### Nombres con verbos descriptivos

<Code code={`# Funciones con verbos claros
def obtener_edad_usuario():
    return 25

def calcular_area_rectangulo(base, altura):
    return base * altura

def validar_email(email):
    return "@" in email

def formatear_fecha(dia, mes, anio):
    return f"{dia:02d}/{mes:02d}/{anio}"

def es_numero_par(numero):
    return numero % 2 == 0

def tiene_mayusculas(texto):
    return any(c.isupper() for c in texto)`} lang="python" title="Verbos descriptivos" />

### Funciones con nombres autodocumentados

<Code code={`# El nombre explica claramente qué hace
def convertir_celsius_a_fahrenheit(celsius):
    return (celsius * 9/5) + 32

def calcular_precio_con_descuento(precio, descuento):
    return precio * (1 - descuento / 100)

def obtener_primer_elemento_lista(lista):
    return lista[0] if lista else None

def verificar_si_es_mayor_de_edad(edad):
    return edad >= 18

# Uso claro sin necesidad de documentación adicional
temperatura_f = convertir_celsius_a_fahrenheit(25)
precio_final = calcular_precio_con_descuento(100, 20)
primer_item = obtener_primer_elemento_lista([1, 2, 3])
es_mayor = verificar_si_es_mayor_de_edad(20)`} lang="python" title="Autodocumentados" />

### Consistencia en el código

<Code code={`# Módulo de gestión de usuarios - Nombres consistentes

def obtener_usuario_por_id(user_id):
    """Obtiene un usuario por su ID."""
    pass

def obtener_usuario_por_email(email):
    """Obtiene un usuario por su email."""
    pass

def crear_usuario(nombre, email):
    """Crea un nuevo usuario."""
    pass

def actualizar_usuario(user_id, datos):
    """Actualiza los datos de un usuario."""
    pass

def eliminar_usuario(user_id):
    """Elimina un usuario."""
    pass

def validar_datos_usuario(datos):
    """Valida los datos de un usuario."""
    pass

# Patrón consistente: verbo + sustantivo + complemento`} lang="python" title="Consistencia" />

### Funciones booleanas

<Code code={`# Funciones que retornan booleano: usar is_, has_, can_

def es_numero_primo(numero):
    """Verifica si un número es primo."""
    if numero < 2:
        return False
    for i in range(2, numero):
        if numero % i == 0:
            return False
    return True

def tiene_caracteres_especiales(texto):
    """Verifica si el texto tiene caracteres especiales."""
    especiales = "!@#$%^&*()_+-=[]{}|;:,.<>?"
    return any(c in especiales for c in texto)

def puede_votar(edad):
    """Verifica si una persona puede votar."""
    return edad >= 18

def esta_vacio(lista):
    """Verifica si una lista está vacía."""
    return len(lista) == 0

# Uso intuitivo en condicionales
if es_numero_primo(7):
    print("Es primo")

if tiene_caracteres_especiales("abc!"):
    print("Tiene caracteres especiales")`} lang="python" title="Funciones booleanas" />

<Aside type="tip" title="💡 Reglas de oro">
1. **Claridad sobre brevedad**: Mejor `calcular_promedio_notas` que `calc_prom`
2. **Verbos para acciones**: `obtener`, `calcular`, `validar`, `crear`, `actualizar`
3. **Prefijos booleanos**: `es_`, `tiene_`, `puede_` para funciones que retornan bool
4. **Consistencia**: Mantén el mismo estilo en todo el proyecto
5. **Evita redundancia**: No uses `funcion_` al inicio (ya es obvio que es una función)
</Aside>

</TabItem>
</Tabs>

---

## 🎯 Resumen de la lección

<Aside type="tip" title="📚 Lo que aprendiste">
En esta lección sobre funciones en Python has aprendido:

✅ **Concepto de función**: Bloques reutilizables de código para modularidad y mantenibilidad  
✅ **Definición con def**: Sintaxis, parámetros, cuerpo, docstring y return  
✅ **Parámetros y argumentos**: Posicionales, por nombre, valores de retorno simples y múltiples  
✅ **Valores por defecto**: Parámetros opcionales para mayor flexibilidad  
✅ **Buenas prácticas**: Nomenclatura clara, verbos descriptivos, nombres autodocumentados  

**Próximo paso**: En la siguiente lección aprenderás sobre módulos y paquetes en Python.
</Aside>
